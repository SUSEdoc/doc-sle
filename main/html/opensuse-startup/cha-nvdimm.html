<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Persistent memory | Start-Up | openSUSE Leap 15.6</title><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" /><link rel="stylesheet" type="text/css" href="static/css/style.css" /><link rel="stylesheet" type="text/css" href="static/css/highlight.css" />
<meta name="title" content="Persistent memory | openSUSE Leap 15.6" />
<meta name="description" content="This chapter contains additional information about using openSUSE Leap with non-volatile main memory, also known as Persistent Memory, comprising one or more N…" />
<meta name="product-name" content="openSUSE Leap" />
<meta name="product-number" content="15.6" />
<meta name="book-title" content="Start-Up" />
<meta name="chapter-title" content="Chapter 19. Persistent memory" />
<meta name="tracker-url" content="https://bugzilla.opensuse.org/enter_bug.cgi" />
<meta name="tracker-type" content="bsc" />
<meta name="tracker-bsc-assignee" content="fs@suse.com" />
<meta name="tracker-bsc-component" content="Documentation" />
<meta name="tracker-bsc-product" content="openSUSE Distribution" />
<meta name="tracker-bsc-version" content="Leap 15.4" />
<meta property="og:title" content="Persistent memory | openSUSE Leap 15.6" />
<meta property="og:description" content="This chapter contains additional information about using openSUSE Leap with non-volatile main memory, also known as Persistent Memory, comprising one or more N…" />
<meta property="og:type" content="article" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Persistent memory | openSUSE Leap 15.6" />
<meta name="twitter:description" content="This chapter contains additional information about using openSUSE Leap with non-volatile main memory, also known as Persistent Memory, comprising one or more N…" />
<link rel="home" href="index.html" title="openSUSE Leap Documentation" /><link rel="up" href="part-hardware.html" title="Part V. Hardware configuration" /><link rel="prev" href="sec-yast-hw-scan.html" title="Chapter 18. Setting up a scanner" /><link rel="next" href="part-help.html" title="Part VI. Help and troubleshooting" />
<script type="text/javascript">

if ( window.location.protocol.toLowerCase() != 'file:' ) {
  document.write('<link rel="stylesheet" type="text/css" href="https://documentation.suse.com/docserv/res/fonts/poppins/poppins.css"></link>');
};

</script><noscript><link rel="stylesheet" type="text/css" href="https://documentation.suse.com/docserv/res/fonts/poppins/poppins.css" /></noscript><script src="static/js/jquery-1.12.4.min.js" type="text/javascript"></script><script src="static/js/script.js" type="text/javascript"></script><script src="static/js/highlight.min.js" type="text/javascript"></script><script>

$(document).ready(function() {
  $('.verbatim-wrap.highlight').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});
hljs.configure({
  useBR: false
});

</script></head><body class="draft offline js-off" onload="$('#betawarn-button-wrap').toggle();if (document.cookie.length > 0) {if (document.cookie.indexOf('betawarn=closed') != -1){$('#betawarn').toggle()}};"><div id="betawarn" style="position:fixed;bottom:0;z-index:9025;background-color:#FDE8E8;padding:1em;margin-left:10%;margin-right:10%;display:block;border-top:.75em solid #E11;width:80%"><p style="color:#333;margin:1em 0;padding:0;">This is a draft document that was built and uploaded automatically. It may document beta software and be incomplete or even incorrect. <strong>Use this document at your own risk.</strong></p> <div id="betawarn-button-wrap" style="display:none;margin:0;padding:0;"><a href="#" onclick="$('#betawarn').toggle();var d=new Date();d.setTime(d.getTime()+(0.5*24*60*60*1000));document.cookie='betawarn=closed; expires='+d.toUTCString()+'; path=/'; return false;" style="color:#333;text-decoration:underline;float:left;margin-top:.5em;padding:1em;display:block;background-color:#FABEBE;">I understand this is a draft</a></div></div><div class="bypass-block"><a href="#_content">Jump to content</a><a href="#_bottom-navigation">Jump to page navigation: previous page [access key p]/next page [access key n]</a></div><div id="_outer-wrap"><div id="_white-bg" style="background-color: #E11;"><div id="_header"><div id="_logo"><img src="static/images/logo.svg" alt="Logo" /></div><div class="crumbs"><a class="book-link" href="index.html" title="Start-Up"><span class="book-icon">Start-Up</span></a><span> › </span><a class="crumb" href="part-hardware.html">Hardware configuration</a><span> › </span><a class="crumb" href="cha-nvdimm.html">Persistent memory</a></div><div class="clearme"></div></div></div><div id="_toolbar-wrap"><div id="_toolbar"><div id="_toc-area" class="inactive"><a id="_toc-area-button" class="tool" title="Contents" accesskey="c" href="index.html"><span class="tool-spacer"><span class="toc-icon">Contents</span><span class="clearme"></span></span><span class="tool-label">Contents</span></a><div class="active-contents bubble-corner"></div><div class="active-contents bubble"><div class="bubble-container"><h6>Start-Up</h6><div id="_bubble-toc"><ol><li class="inactive"><a href="preface-start-up.html"><span class="number"> </span><span class="name">About this guide</span></a></li><li class="inactive"><a href="part-basics.html"><span class="number">I </span><span class="name">Installation</span></a><ol><li class="inactive"><a href="art-opensuse-installquick.html"><span class="number">1 </span><span class="name">Installation Quick Start</span></a></li><li class="inactive"><a href="cha-boot-parameters.html"><span class="number">2 </span><span class="name">Boot parameters</span></a></li><li class="inactive"><a href="cha-install.html"><span class="number">3 </span><span class="name">Installation steps</span></a></li><li class="inactive"><a href="cha-installation-troubleshooting.html"><span class="number">4 </span><span class="name">Troubleshooting</span></a></li></ol></li><li class="inactive"><a href="part-reference-administration.html"><span class="number">II </span><span class="name">Administration</span></a><ol><li class="inactive"><a href="cha-yast-userman.html"><span class="number">5 </span><span class="name">Managing users with YaST</span></a></li><li class="inactive"><a href="cha-yast-lang.html"><span class="number">6 </span><span class="name">Changing language and country settings with YaST</span></a></li><li class="inactive"><a href="cha-print.html"><span class="number">7 </span><span class="name">Printer operation</span></a></li><li class="inactive"><a href="cha-fuse.html"><span class="number">8 </span><span class="name">Accessing file systems with FUSE</span></a></li></ol></li><li class="inactive"><a href="part-reference-software.html"><span class="number">III </span><span class="name">Managing and updating software</span></a><ol><li class="inactive"><a href="cha-yast-software.html"><span class="number">9 </span><span class="name">Installing or removing software</span></a></li><li class="inactive"><a href="cha-add-ons.html"><span class="number">10 </span><span class="name">Installing add-on products</span></a></li><li class="inactive"><a href="cha-onlineupdate-you.html"><span class="number">11 </span><span class="name">YaST online update</span></a></li><li class="inactive"><a href="cha-update-osuse.html"><span class="number">12 </span><span class="name">Upgrading the system and system changes</span></a></li></ol></li><li class="inactive"><a href="part-bash.html"><span class="number">IV </span><span class="name">The Bash shell</span></a><ol><li class="inactive"><a href="cha-new-bash.html"><span class="number">13 </span><span class="name">Shell basics</span></a></li><li class="inactive"><a href="cha-adm-shell.html"><span class="number">14 </span><span class="name">Bash and Bash scripts</span></a></li></ol></li><li class="inactive"><a href="part-hardware.html"><span class="number">V </span><span class="name">Hardware configuration</span></a><ol><li class="inactive"><a href="sec-yast-hw-keym.html"><span class="number">15 </span><span class="name">Setting up your system keyboard layout</span></a></li><li class="inactive"><a href="sec-yast-hw-sound.html"><span class="number">16 </span><span class="name">Setting up sound cards</span></a></li><li class="inactive"><a href="sec-yast-hw-print.html"><span class="number">17 </span><span class="name">Setting up a printer</span></a></li><li class="inactive"><a href="sec-yast-hw-scan.html"><span class="number">18 </span><span class="name">Setting up a scanner</span></a></li><li class="inactive"><a href="cha-nvdimm.html"><span class="number">19 </span><span class="name">Persistent memory</span></a></li></ol></li><li class="inactive"><a href="part-help.html"><span class="number">VI </span><span class="name">Help and troubleshooting</span></a><ol><li class="inactive"><a href="cha-adminhelp.html"><span class="number">20 </span><span class="name">Help and documentation</span></a></li><li class="inactive"><a href="cha-trouble.html"><span class="number">21 </span><span class="name">Common problems and their solutions</span></a></li></ol></li><li class="inactive"><a href="bk01apa.html"><span class="number">A </span><span class="name">GNU licenses</span></a></li></ol></div><div class="clearme"></div></div></div></div><div id="_nav-area" class="inactive"><div class="tool"><span class="nav-inner"><span class="tool-label">Navigation</span><a accesskey="p" class="tool-spacer" title="Chapter 18. Setting up a scanner" href="sec-yast-hw-scan.html"><span class="prev-icon">←</span></a><a accesskey="n" class="tool-spacer" title="Part VI. Help and troubleshooting" href="part-help.html"><span class="next-icon">→</span></a></span></div></div></div></div><div id="_fixed-header-wrap" style="background-color: #E11;" class="inactive"><div id="_fixed-header"><div class="crumbs"><a class="book-link" href="index.html" title="Start-Up"><span class="book-icon">Start-Up</span></a><span> › </span><a class="crumb" href="part-hardware.html">Hardware configuration</a><span> › </span><a class="crumb" href="cha-nvdimm.html">Persistent memory</a></div><div class="buttons"><a class="top-button button" href="#">Top</a><div class="button"><a accesskey="p" class="tool-spacer" title="Chapter 18. Setting up a scanner" href="sec-yast-hw-scan.html"><span class="prev-icon">←</span></a><a accesskey="n" class="tool-spacer" title="Part VI. Help and troubleshooting" href="part-help.html"><span class="next-icon">→</span></a></div><div class="clearme"></div></div><div class="clearme"></div></div></div><div id="_content" class="draft "><div class="documentation"><div class="chapter " id="cha-nvdimm"><div class="titlepage"><div><div class="version-info">Applies to  <span class="productname "><span class="productname"><span class="phrase">openSUSE Leap</span></span></span> <span class="productnumber "><span class="productnumber"><span class="phrase">15.6</span></span></span></div><div><h2 class="title"><span class="number">19 </span><span xmlns:dm="urn:x-suse:ns:docmanager" class="name">Persistent memory</span> <a title="Permalink" class="permalink" href="cha-nvdimm.html#">#</a><a class="report-bug" rel="nofollow" target="_blank" href="https://github.com/SUSE/doc-sle/edit/main/xml/hardware_nvdimm.xml" title="Edit the source file for this section">Edit source</a></h2><div class="doc-status"><ul><li><span class="ds-label">File Name: </span>hardware_nvdimm.xml</li><li><span class="ds-label">ID: </span>cha-nvdimm</li></ul></div></div><div><div class="abstract"><div class="abstract-title-wrap"><h6 class="abstract-title">Abstract<a title="Permalink" class="permalink" href="cha-nvdimm.html#id-1.3.7.6.2.1">#</a></h6></div><p>
    This chapter contains additional information about using <span class="productname"><span class="phrase">openSUSE Leap</span></span> with
    non-volatile main memory, also known as <span class="emphasis"><em>Persistent Memory</em></span>,
    comprising one or more NVDIMMs.
   </p></div></div></div></div><div class="line"><div class="toc"><dl><dt><span class="sect1"><a href="cha-nvdimm.html#sec-nvdimm-intro"><span class="number">19.1 </span><span class="name">Introduction</span></a></span></dt><dt><span class="sect1"><a href="cha-nvdimm.html#sec-nvdimm-terms"><span class="number">19.2 </span><span class="name">Terms</span></a></span></dt><dt><span class="sect1"><a href="cha-nvdimm.html#sec-nvdimm-uses"><span class="number">19.3 </span><span class="name">Use cases</span></a></span></dt><dt><span class="sect1"><a href="cha-nvdimm.html#sec-nvdimm-tools"><span class="number">19.4 </span><span class="name">Tools for managing persistent memory</span></a></span></dt><dt><span class="sect1"><a href="cha-nvdimm.html#sec-nvdimm-setup"><span class="number">19.5 </span><span class="name">Setting up persistent memory</span></a></span></dt><dt><span class="sect1"><a href="cha-nvdimm.html#sec-nvdimm-moreinfo"><span class="number">19.6 </span><span class="name">More information</span></a></span></dt></dl></div></div><div class="sect1 " id="sec-nvdimm-intro"><div class="titlepage"><div><div><h2 class="title"><span class="number">19.1 </span><span xmlns:dm="urn:x-suse:ns:docmanager" class="name">Introduction</span> <a title="Permalink" class="permalink" href="cha-nvdimm.html#sec-nvdimm-intro">#</a><a class="report-bug" rel="nofollow" target="_blank" href="https://github.com/SUSE/doc-sle/edit/main/xml/hardware_nvdimm.xml" title="Edit the source file for this section">Edit source</a></h2><div class="doc-status"><ul><li><span class="ds-label">File Name: </span>hardware_nvdimm.xml</li><li><span class="ds-label">ID: </span>sec-nvdimm-intro</li></ul></div></div></div></div><p>
   Persistent memory is a new type of computer storage, combining speeds
   approaching those of dynamic RAM (DRAM) along with RAM's byte-by-byte
   addressability, plus the permanence of solid-state drives (SSDs).
  </p><p>
   SUSE currently supports the use of persistent memory with <span class="productname"><span class="phrase">openSUSE Leap</span></span> on machines
   with the AMD64/Intel 64 and POWER architectures.
  </p><p>
   Like conventional RAM, persistent memory is installed directly into
   mainboard memory slots. As such, it is supplied in the same physical form
   factor as RAM—as DIMMs. These are known as NVDIMMs: non-volatile dual
   inline memory modules.
  </p><p>
   Unlike RAM, though, persistent memory is also similar to flash-based SSDs in
   several ways. Both are based on forms of solid-state memory circuitry, but
   despite this, both provide non-volatile storage: Their contents are retained
   when the system is powered off or restarted. For both forms of medium,
   writing data is slower than reading it, and both support a limited number of
   rewrite cycles. Finally, also like SSDs, sector-level access to persistent
   memory is possible if that is more suitable for a particular application.
  </p><p>
   Different models use different forms of electronic storage medium, such as
   Intel 3D XPoint, or a combination of NAND-flash and DRAM. New forms of
   non-volatile RAM are also in development. This means that different vendors
   and models of NVDIMM offer different performance and durability
   characteristics.
  </p><p>
   Because the storage technologies involved are in an early stage of
   development, different vendors' hardware may impose different limitations.
   Thus, the following statements are generalizations.
  </p><p>
   Persistent memory is up to ten times slower than DRAM, but around a thousand
   times faster than flash storage. It can be rewritten on a byte-by-byte basis
   rather than flash memory's whole-sector erase-and-rewrite process. Finally,
   while rewrite cycles are limited, most forms of persistent memory can handle
   millions of rewrites, compared to the thousands of cycles of flash storage.
  </p><p>
   This has two important consequences:
  </p><div class="itemizedlist "><ul class="itemizedlist"><li class="listitem "><p>
     It is not possible with current technology to run a system with only
     persistent memory and thus achieve non-volatile main memory. You
     must use a mixture of both conventional RAM and NVDIMMs. The operating
     system and applications will execute in conventional RAM, with the NVDIMMs
     providing fast supplementary storage.
    </p></li><li class="listitem "><p>
     The performance characteristics of different vendors' persistent memory
     mean that it may be necessary for programmers to be aware of the hardware
     specifications of the NVDIMMs in a particular server, including how many
     NVDIMMs there are and in which memory slots they are fitted. This will
     impact hypervisor use, migration of software between different
     host machines, and so on.
    </p></li></ul></div><p>
   This new storage subsystem is defined in version 6 of the ACPI standard.
   However, <code class="filename">libnvdimm</code> supports pre-standard NVDIMMs and
   they can be used in the same way.
  </p><div id="id-1.3.7.6.3.12" class="admonition tip normal"><img class="symbol" alt="Tip" title="Tip" src="static/images/icon-tip.svg" /><h6>Tip: Intel Optane DC Persistent Memory</h6><p>
    Intel Optane DIMMs memory can be used in specific modes:
   </p><div class="itemizedlist "><ul class="itemizedlist"><li class="listitem "><p>
      In <span class="emphasis"><em>App Direct Mode</em></span>, the Intel Optane memory is used as
      fast persistent storage, an alternative to SSDs and NVMe devices. Data in
      this mode is kept when the system is powered off.
     </p></li><li class="listitem "><p>
      In <span class="emphasis"><em>Memory Mode</em></span>, the Intel Optane memory serves as a
      cost-effective, high-capacity alternative to DRAM. In this mode, separate
      DRAM DIMMs act as a cache for the most frequently accessed data while the
      Optane DIMMs memory provides large memory capacity. However, compared with
      DRAM-only systems, this mode is slower under random access workloads. If
      you run applications without Optane-specific enhancements that take
      advantage of this mode, memory performance may decrease. Data in this
      mode is lost when the system is powered off.
     </p></li><li class="listitem "><p>
      In <span class="emphasis"><em>Mixed Mode</em></span>, the Intel Optane memory is
      partitioned, so it can serve in both modes simultaneously.
     </p></li></ul></div></div></div><div class="sect1 " id="sec-nvdimm-terms"><div class="titlepage"><div><div><h2 class="title"><span class="number">19.2 </span><span xmlns:dm="urn:x-suse:ns:docmanager" class="name">Terms</span> <a title="Permalink" class="permalink" href="cha-nvdimm.html#sec-nvdimm-terms">#</a><a class="report-bug" rel="nofollow" target="_blank" href="https://github.com/SUSE/doc-sle/edit/main/xml/hardware_nvdimm.xml" title="Edit the source file for this section">Edit source</a></h2><div class="doc-status"><ul><li><span class="ds-label">File Name: </span>hardware_nvdimm.xml</li><li><span class="ds-label">ID: </span>sec-nvdimm-terms</li></ul></div></div></div></div><div class="variablelist "><dl class="variablelist"><dt id="id-1.3.7.6.4.2.1"><span class="term ">Region</span></dt><dd><p>
      A <span class="emphasis"><em>region</em></span> is a block of persistent memory that can
      be divided up into one or more <span class="emphasis"><em>namespace</em></span>s. You
      cannot access the persistent memory of a region without first allocating
      it to a namespace.
     </p></dd><dt id="id-1.3.7.6.4.2.2"><span class="term ">Namespace</span></dt><dd><p>
      A single contiguously addressed range of non-volatile storage, comparable
      to NVM Express SSD namespaces, or to SCSI Logical Units (LUNs). Namespaces
      appear in the server's <code class="filename">/dev</code> directory as separate
      block devices. Depending on the method of access required, namespaces can
      either amalgamate storage from multiple NVDIMMs into larger volumes, or
      allow it to be partitioned into smaller volumes.
     </p></dd><dt id="id-1.3.7.6.4.2.3"><span class="term ">Mode</span></dt><dd><p>
      Each namespace also has a <span class="emphasis"><em>mode</em></span> that defines which
      NVDIMM features are enabled for that namespace. Sibling namespaces of the
      same parent region always have the same type, but might be
      configured to have different modes. Namespace modes include:
     </p><div class="variablelist "><dl class="variablelist"><dt id="id-1.3.7.6.4.2.3.2.2.1"><span class="term ">devdax</span></dt><dd><p>
         Device-DAX mode. Creates a single-character device file (<code class="filename">
          /dev/dax<em class="replaceable ">X</em>.<em class="replaceable ">Y</em>
         </code>). Does <span class="emphasis"><em>not</em></span> require file system
         creation.
        </p></dd><dt id="id-1.3.7.6.4.2.3.2.2.2"><span class="term ">fsdax</span></dt><dd><p>
         File system-DAX mode. Default if no other mode is specified. Creates a
         block device (<code class="filename">/dev/pmem<em class="replaceable ">X</em>
          [.<em class="replaceable ">Y</em>]</code>) which supports DAX for
         <code class="literal">ext4</code> or <code class="literal">XFS</code>.
        </p></dd><dt id="id-1.3.7.6.4.2.3.2.2.3"><span class="term ">sector</span></dt><dd><p>
         For legacy file systems which do not checksum metadata. Suitable for
         small boot volumes. Compatible with other operating systems.
        </p></dd><dt id="id-1.3.7.6.4.2.3.2.2.4"><span class="term ">raw</span></dt><dd><p>
         A memory disk without a label or metadata. Does not support DAX.
         Compatible with other operating systems.
        </p><div id="id-1.3.7.6.4.2.3.2.2.4.2.2" class="admonition note normal"><img class="symbol" alt="Note" title="Note" src="static/images/icon-note.svg" /><h6>Note</h6><p>
          <code class="literal">raw</code> mode is not supported by SUSE. It is not
          possible to mount file systems on <code class="literal">raw</code> namespaces.
         </p></div></dd></dl></div></dd><dt id="id-1.3.7.6.4.2.4"><span class="term ">Type</span></dt><dd><p>
      Each namespace and region has a <span class="emphasis"><em>type</em></span> that defines
      how the persistent memory associated with that namespace or
      region can be accessed. A namespace always has the same type as its
      parent region. There are two different types: Persistent Memory, which
      can be configured in two different ways, and the deprecated Block Mode.
     </p><div class="variablelist "><dl class="variablelist"><dt id="id-1.3.7.6.4.2.4.2.2.1"><span class="term ">Persistent memory (PMEM)</span></dt><dd><p>
         PMEM storage offers byte-level access, similar to RAM. Using PMEM, a
         single namespace can include multiple interleaved NVDIMMs, allowing
         them all to be used as a single device.
        </p><p>
         There are two ways to configure a PMEM namespace.
        </p><div class="variablelist "><dl class="variablelist"><dt id="id-1.3.7.6.4.2.4.2.2.1.2.3.1"><span class="term ">PMEM with DAX</span></dt><dd><p>
            A PMEM namespace configured for Direct Access (DAX) means that
            accessing the memory bypasses the kernel's page cache and goes
            direct to the medium. Software can directly read or write every
            byte of the namespace separately.
           </p></dd><dt id="id-1.3.7.6.4.2.4.2.2.1.2.3.2"><span class="term ">PMEM with block translation table (BTT)</span></dt><dd><p>
            A PMEM namespace configured to operate in BTT mode is accessed on a
            sector-by-sector basis, like a conventional disk drive, rather than
            the more RAM-like byte-addressable model. A translation table
            mechanism batches accesses into sector-sized units.
           </p><p>
            The advantage of BTT is data protection. The storage subsystem
            ensures that each sector is completely written to the underlying
            medium. If a sector cannot be completely written (that is, if the
            write operation fails for some reason), then the whole sector will
            be rolled back to its previous state. Thus a given sector cannot be
            partially written.
           </p><p>
            Additionally, access to BTT namespaces is cached by the kernel.
           </p><p>
            The drawback is that DAX is not possible for BTT namespaces.
           </p></dd></dl></div></dd><dt id="id-1.3.7.6.4.2.4.2.2.2"><span class="term ">Block mode (BLK)</span></dt><dd><p>
         Block mode storage addresses each NVDIMM as a separate device. Its use
         is deprecated and no longer supported.
        </p></dd></dl></div><p>
      Apart from <code class="literal">devdax</code> namespaces, all other types must be
      formatted with a file system, just as with a conventional drive.
      <span class="productname"><span class="phrase">openSUSE Leap</span></span> supports the <code class="literal">ext2</code>,
      <code class="literal">ext4</code> and <code class="literal">XFS</code> file systems for this.
     </p></dd><dt id="id-1.3.7.6.4.2.5"><span class="term ">Direct access (DAX)</span></dt><dd><p>
      DAX allows persistent memory to be directly mapped into a process's
      address space, for example, using the <code class="literal">mmap</code> system call.
     </p></dd><dt id="id-1.3.7.6.4.2.6"><span class="term ">DIMM physical address (DPA)</span></dt><dd><p>
      A memory address as an offset into a single DIMM's memory; that is,
      starting from zero as the lowest addressable byte on that DIMM.
     </p></dd><dt id="id-1.3.7.6.4.2.7"><span class="term ">Label</span></dt><dd><p>
      Metadata stored on the NVDIMM, such as namespace definitions. This can be
      accessed using DSMs.
     </p></dd><dt id="id-1.3.7.6.4.2.8"><span class="term ">Device-specific method (DSM)</span></dt><dd><p>
      ACPI method to access the firmware on an NVDIMM.
     </p></dd></dl></div></div><div class="sect1 " id="sec-nvdimm-uses"><div class="titlepage"><div><div><h2 class="title"><span class="number">19.3 </span><span xmlns:dm="urn:x-suse:ns:docmanager" class="name">Use cases</span> <a title="Permalink" class="permalink" href="cha-nvdimm.html#sec-nvdimm-uses">#</a><a class="report-bug" rel="nofollow" target="_blank" href="https://github.com/SUSE/doc-sle/edit/main/xml/hardware_nvdimm.xml" title="Edit the source file for this section">Edit source</a></h2><div class="doc-status"><ul><li><span class="ds-label">File Name: </span>hardware_nvdimm.xml</li><li><span class="ds-label">ID: </span>sec-nvdimm-uses</li></ul></div></div></div></div><div class="sect2 " id="sec-nvdimm-uses-pmem"><div class="titlepage"><div><div><h3 class="title"><span class="number">19.3.1 </span><span xmlns:dm="urn:x-suse:ns:docmanager" class="name">PMEM with DAX</span> <a title="Permalink" class="permalink" href="cha-nvdimm.html#sec-nvdimm-uses-pmem">#</a><a class="report-bug" rel="nofollow" target="_blank" href="https://github.com/SUSE/doc-sle/edit/main/xml/hardware_nvdimm.xml" title="Edit the source file for this section">Edit source</a></h3><div class="doc-status"><ul><li><span class="ds-label">File Name: </span>hardware_nvdimm.xml</li><li><span class="ds-label">ID: </span>sec-nvdimm-uses-pmem</li></ul></div></div></div></div><p>
    This form of memory access is
    <span class="emphasis"><em>not</em></span> transactional. In the event of a power outage or
    other system failure, data may not be written into storage. PMEM storage is
    only suitable if the application can handle the situation of partially
    written data.
   </p><div class="sect3 " id="id-1.3.7.6.5.2.3"><div class="titlepage"><div><div><h4 class="title"><span class="number">19.3.1.1 </span><span xmlns:dm="urn:x-suse:ns:docmanager" class="name">
     Applications that benefit from large amounts of byte-addressable storage</span> <a title="Permalink" class="permalink" href="cha-nvdimm.html#id-1.3.7.6.5.2.3">#</a><a class="report-bug" rel="nofollow" target="_blank" href="https://github.com/SUSE/doc-sle/edit/main/xml/hardware_nvdimm.xml" title="Edit the source file for this section">Edit source</a></h4><div class="doc-status"><ul><li><span class="ds-label">File Name: </span>hardware_nvdimm.xml</li><li><span class="ds-label">ID: </span><span class="ds-message">no ID found</span></li></ul></div></div></div></div><p>
     If the server will host an application that can directly use large amounts
     of fast storage on a byte-by-byte basis, the programmer can use the <code class="literal">mmap</code>
     system call to place blocks of persistent memory directly into the
     application's address space, without using any additional system RAM.
    </p></div><div class="sect3 " id="id-1.3.7.6.5.2.4"><div class="titlepage"><div><div><h4 class="title"><span class="number">19.3.1.2 </span><span xmlns:dm="urn:x-suse:ns:docmanager" class="name">Avoiding use of the kernel page cache</span> <a title="Permalink" class="permalink" href="cha-nvdimm.html#id-1.3.7.6.5.2.4">#</a><a class="report-bug" rel="nofollow" target="_blank" href="https://github.com/SUSE/doc-sle/edit/main/xml/hardware_nvdimm.xml" title="Edit the source file for this section">Edit source</a></h4><div class="doc-status"><ul><li><span class="ds-label">File Name: </span>hardware_nvdimm.xml</li><li><span class="ds-label">ID: </span><span class="ds-message">no ID found</span></li></ul></div></div></div></div><p>
     Avoid using the kernel page cache to conserve the use of RAM for the page cache, and instead
     give it to your applications. For instance, non-volatile memory could be
     dedicated to holding virtual machine (VM) images. As these would not be
     cached, this would reduce the cache usage on the host, allowing more VMs
     per host.
    </p></div></div><div class="sect2 " id="id-1.3.7.6.5.3"><div class="titlepage"><div><div><h3 class="title"><span class="number">19.3.2 </span><span xmlns:dm="urn:x-suse:ns:docmanager" class="name">PMEM with BTT</span> <a title="Permalink" class="permalink" href="cha-nvdimm.html#id-1.3.7.6.5.3">#</a><a class="report-bug" rel="nofollow" target="_blank" href="https://github.com/SUSE/doc-sle/edit/main/xml/hardware_nvdimm.xml" title="Edit the source file for this section">Edit source</a></h3><div class="doc-status"><ul><li><span class="ds-label">File Name: </span>hardware_nvdimm.xml</li><li><span class="ds-label">ID: </span><span class="ds-message">no ID found</span></li></ul></div></div></div></div><p>
    This is useful when you want to use the persistent memory on a set of
    NVDIMMs as a disk-like pool of fast storage. For example, placing
    the file system journal on PMEM with BTT increases the reliability
    of file system recovery after a power failure or other sudden
    interruption (see <a class="xref" href="cha-nvdimm.html#sec-nvdimm-setup-btt" title="19.5.3. Creating a PMEM namespace with BTT">Section 19.5.3, “Creating a PMEM namespace with BTT”</a>).
   </p><p>
    To applications, such devices appear as fast SSDs and can be used
    like any other storage device. For example, LVM can be layered on top of
    the persistent memory and will work as normal.
   </p><p>
    The advantage of BTT is that sector write atomicity is guaranteed, so even
    sophisticated applications that depend on data integrity will keep
    working. Media error reporting works through standard error-reporting
    channels.
   </p></div></div><div class="sect1 " id="sec-nvdimm-tools"><div class="titlepage"><div><div><h2 class="title"><span class="number">19.4 </span><span xmlns:dm="urn:x-suse:ns:docmanager" class="name">Tools for managing persistent memory</span> <a title="Permalink" class="permalink" href="cha-nvdimm.html#sec-nvdimm-tools">#</a><a class="report-bug" rel="nofollow" target="_blank" href="https://github.com/SUSE/doc-sle/edit/main/xml/hardware_nvdimm.xml" title="Edit the source file for this section">Edit source</a></h2><div class="doc-status"><ul><li><span class="ds-label">File Name: </span>hardware_nvdimm.xml</li><li><span class="ds-label">ID: </span>sec-nvdimm-tools</li></ul></div></div></div></div><p>
   To manage persistent memory, it is necessary to install the
   <code class="literal">ndctl</code> package. This also installs the
   <code class="filename">libndctl</code> package, which provides a set of user space
   libraries to configure NVDIMMs.
  </p><p>
   These tools work via the <code class="filename">libnvdimm</code> library, which
   supports three types of NVDIMM:
  </p><div class="itemizedlist "><ul class="itemizedlist"><li class="listitem "><p>
     PMEM
    </p></li><li class="listitem "><p>
     BLK
    </p></li><li class="listitem "><p>
     Simultaneous PMEM and BLK
    </p></li></ul></div><p>
   The <code class="command">ndctl</code> utility has a helpful set of
   <code class="command">man</code> pages, accessible with the command:
  </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">&gt; </code><code class="command">ndctl help <em class="replaceable ">subcommand</em></code></pre></div><p>
   To see a list of available subcommands, use:
  </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">&gt; </code><code class="command">ndctl --list-cmds</code></pre></div><p>
   The available subcommands include:
  </p><div class="variablelist "><dl class="variablelist"><dt id="id-1.3.7.6.6.10.1"><span class="term ">version</span></dt><dd><p>
      Displays the current version of the NVDIMM support tools.
     </p></dd><dt id="id-1.3.7.6.6.10.2"><span class="term ">enable-namespace</span></dt><dd><p>
      Makes the specified namespace available for use.
     </p></dd><dt id="id-1.3.7.6.6.10.3"><span class="term ">disable-namespace</span></dt><dd><p>
      Prevents the specified namespace from being used.
     </p></dd><dt id="id-1.3.7.6.6.10.4"><span class="term ">create-namespace</span></dt><dd><p>
      Creates a new namespace from the specified storage devices.
     </p></dd><dt id="id-1.3.7.6.6.10.5"><span class="term ">destroy-namespace</span></dt><dd><p>
      Removes the specified namespace.
     </p></dd><dt id="id-1.3.7.6.6.10.6"><span class="term ">enable-region</span></dt><dd><p>
      Makes the specified region available for use.
     </p></dd><dt id="id-1.3.7.6.6.10.7"><span class="term ">disable-region</span></dt><dd><p>
      Prevents the specified region from being used.
     </p></dd><dt id="id-1.3.7.6.6.10.8"><span class="term ">zero-labels</span></dt><dd><p>
      Erases the metadata from a device.
     </p></dd><dt id="id-1.3.7.6.6.10.9"><span class="term ">read-labels</span></dt><dd><p>
      Retrieves the metadata of the specified device.
     </p></dd><dt id="id-1.3.7.6.6.10.10"><span class="term ">list</span></dt><dd><p>
      Displays available devices.
     </p></dd><dt id="id-1.3.7.6.6.10.11"><span class="term ">help</span></dt><dd><p>
      Displays information about using the tool.
     </p></dd></dl></div></div><div class="sect1 " id="sec-nvdimm-setup"><div class="titlepage"><div><div><h2 class="title"><span class="number">19.5 </span><span xmlns:dm="urn:x-suse:ns:docmanager" class="name">Setting up persistent memory</span> <a title="Permalink" class="permalink" href="cha-nvdimm.html#sec-nvdimm-setup">#</a><a class="report-bug" rel="nofollow" target="_blank" href="https://github.com/SUSE/doc-sle/edit/main/xml/hardware_nvdimm.xml" title="Edit the source file for this section">Edit source</a></h2><div class="doc-status"><ul><li><span class="ds-label">File Name: </span>hardware_nvdimm.xml</li><li><span class="ds-label">ID: </span>sec-nvdimm-setup</li></ul></div></div></div></div><div class="sect2 " id="sec-nvdimm-setup-view"><div class="titlepage"><div><div><h3 class="title"><span class="number">19.5.1 </span><span xmlns:dm="urn:x-suse:ns:docmanager" class="name">Viewing available NVDIMM storage</span> <a title="Permalink" class="permalink" href="cha-nvdimm.html#sec-nvdimm-setup-view">#</a><a class="report-bug" rel="nofollow" target="_blank" href="https://github.com/SUSE/doc-sle/edit/main/xml/hardware_nvdimm.xml" title="Edit the source file for this section">Edit source</a></h3><div class="doc-status"><ul><li><span class="ds-label">File Name: </span>hardware_nvdimm.xml</li><li><span class="ds-label">ID: </span>sec-nvdimm-setup-view</li></ul></div></div></div></div><p>
    The <code class="command">ndctl</code> <code class="literal">list</code> command can be used to
    list all available NVDIMMs in a system.
   </p><p>
    In the following example, the system has three NVDIMMs, which are in a
    single, triple-channel interleaved set.
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root"># </code><code class="command">ndctl list --dimms</code>

[
 {
  "dev":"nmem2",
  "id":"8089-00-0000-12325476"
 },
 {
  "dev":"nmem1",
  "id":"8089-00-0000-11325476"
 },
 {
  "dev":"nmem0",
  "id":"8089-00-0000-10325476"
 }
]</pre></div><p>
    With a different parameter, <code class="command">ndctl</code>
    <code class="literal">list</code> will also list the available regions.
   </p><div id="id-1.3.7.6.7.2.6" class="admonition note normal"><img class="symbol" alt="Note" title="Note" src="static/images/icon-note.svg" /><h6>Note</h6><p>
     Regions may not appear in numerical order.
    </p></div><p>
    Note that although there are only three NVDIMMs, they appear as four
    regions.
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root"># </code><code class="command">ndctl list --regions</code>

[
 {
  "dev":"region1",
  "size":68182605824,
  "available_size":68182605824,
  "type":"blk"
 },
 {
  "dev":"region3",
  "size":202937204736,
  "available_size":202937204736,
  "type":"pmem",
  "iset_id":5903239628671731251
  },
  {
   "dev":"region0",
   "size":68182605824,
   "available_size":68182605824,
   "type":"blk"
  },
  {
   "dev":"region2",
   "size":68182605824,
   "available_size":68182605824,
   "type":"blk"
  }
]</pre></div><p>
    The space is available in two different forms: either as three separate 64
    regions of type BLK, or as one combined 189 GB region of type PMEM which
    presents all the space on the three interleaved NVDIMMs as a single volume.
   </p><p>
    Note that the displayed value for <code class="literal">available_size</code> is the
    same as that for <code class="literal">size</code>. This means that none of the space
    has been allocated yet.
   </p></div><div class="sect2 " id="sec-nvdimm-setup-dax"><div class="titlepage"><div><div><h3 class="title"><span class="number">19.5.2 </span><span xmlns:dm="urn:x-suse:ns:docmanager" class="name">Configuring the storage as a single PMEM namespace with DAX</span> <a title="Permalink" class="permalink" href="cha-nvdimm.html#sec-nvdimm-setup-dax">#</a><a class="report-bug" rel="nofollow" target="_blank" href="https://github.com/SUSE/doc-sle/edit/main/xml/hardware_nvdimm.xml" title="Edit the source file for this section">Edit source</a></h3><div class="doc-status"><ul><li><span class="ds-label">File Name: </span>hardware_nvdimm.xml</li><li><span class="ds-label">ID: </span>sec-nvdimm-setup-dax</li></ul></div></div></div></div><p>
    For the first example, we will configure our three NVDIMMs into a single
    PMEM namespace with Direct Access (DAX).
   </p><p>
    The first step is to create a new namespace.
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root"># </code><code class="command">ndctl create-namespace --type=<em class="replaceable ">pmem</em> --mode=<em class="replaceable ">fsdax</em> --map=<em class="replaceable ">memory</em></code>
{
 "dev":"namespace3.0",
 "mode":"memory",
 "size":199764213760,
 "uuid":"dc8ebb84-c564-4248-9e8d-e18543c39b69",
 "blockdev":"pmem3"
}</pre></div><p>
    This creates a block device <code class="filename">/dev/pmem3</code>, which supports
    DAX. The <code class="literal">3</code> in the device name is inherited from the
    parent region number, in this case <code class="filename">region3</code>.
   </p><p>
    The <code class="option">--map=memory</code> option sets aside part of the PMEM
    storage space on the NVDIMMs so that it can be used to allocate internal
    kernel data structures called <code class="literal">struct pages</code>. This allows
    the new PMEM namespace to be used with features such as <code class="literal">O_DIRECT
    I/O</code> and <code class="literal">RDMA</code>.
   </p><p>
    The reservation of some persistent memory for kernel data structures is why
    the resulting PMEM namespace has a smaller capacity than the parent PMEM
    region.
   </p><p>
    Next, we verify that the new block device is available to the operating
    system:
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root"># </code><code class="command">fdisk -l /dev/<em class="replaceable ">pmem3</em></code>
Disk /dev/pmem3: 186 GiB, 199764213760 bytes, 390164480 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes</pre></div><p>
    Before it can be used, like any other drive, it must be formatted. In this
    example, we format it with XFS:
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root"># </code><code class="command">mkfs.xfs /dev/<em class="replaceable ">pmem3</em></code>
meta-data=/dev/pmem3      isize=256    agcount=4, agsize=12192640 blks
         =                sectsz=4096  attr=2, projid32bit=1
         =                crc=0        finobt=0, sparse=0
data     =                bsize=4096   blocks=48770560, imaxpct=25
         =                sunit=0      swidth=0 blks
naming   =version 2       bsize=4096   ascii-ci=0 ftype=1
log      =internal log    bsize=4096   blocks=23813, version=2
         =                sectsz=4096  sunit=1 blks, lazy-count=1
realtime =none            extsz=4096   blocks=0, rtextents=0</pre></div><p>
    Next, we can mount the new drive onto a directory:
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root"># </code><code class="command">mount -o dax /dev/<em class="replaceable ">pmem3</em> /mnt/<em class="replaceable ">pmem3</em></code></pre></div><p>
    Then we can verify that we now have a DAX-capable device:
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root"># </code><code class="command">mount | grep dax</code>
/dev/pmem3 on /mnt/pmem3 type xfs (rw,relatime,attr2,dax,inode64,noquota)</pre></div><p>
    The result is that we now have a PMEM namespace formatted with the XFS file
    system and mounted with DAX.
   </p><p>
    Any <code class="literal">mmap()</code> calls to files in that file system will
    return virtual addresses that directly map to the persistent memory on our
    NVDIMMs, bypassing the page cache.
   </p><p>
    Any <code class="literal">fsync</code> or <code class="literal">msync</code> calls on files in
    that file system will still ensure that modified data has been fully
    written to the NVDIMMs. These calls flush the processor cache lines
    associated with any pages that have been modified in user space via
    <code class="literal">mmap</code> mappings.
   </p><div class="sect3 " id="sec-nvdimm-setup-deldax"><div class="titlepage"><div><div><h4 class="title"><span class="number">19.5.2.1 </span><span xmlns:dm="urn:x-suse:ns:docmanager" class="name">Removing a namespace</span> <a title="Permalink" class="permalink" href="cha-nvdimm.html#sec-nvdimm-setup-deldax">#</a><a class="report-bug" rel="nofollow" target="_blank" href="https://github.com/SUSE/doc-sle/edit/main/xml/hardware_nvdimm.xml" title="Edit the source file for this section">Edit source</a></h4><div class="doc-status"><ul><li><span class="ds-label">File Name: </span>hardware_nvdimm.xml</li><li><span class="ds-label">ID: </span>sec-nvdimm-setup-deldax</li></ul></div></div></div></div><p>
     Before creating any other type of volume that uses the same storage, we
     must unmount and then remove this PMEM volume.
    </p><p>
     First, unmount it:
    </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root"># </code><code class="command">umount /mnt/<em class="replaceable ">pmem3</em></code></pre></div><p>
     Then disable the namespace:
    </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root"># </code><code class="command">ndctl disable-namespace <em class="replaceable ">namespace3.0</em></code>
disabled 1 namespace</pre></div><p>
     Then delete it:
    </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root"># </code><code class="command">ndctl destroy-namespace <em class="replaceable ">namespace3.0</em></code>
destroyed 1 namespace</pre></div></div></div><div class="sect2 " id="sec-nvdimm-setup-btt"><div class="titlepage"><div><div><h3 class="title"><span class="number">19.5.3 </span><span xmlns:dm="urn:x-suse:ns:docmanager" class="name">Creating a PMEM namespace with BTT</span> <a title="Permalink" class="permalink" href="cha-nvdimm.html#sec-nvdimm-setup-btt">#</a><a class="report-bug" rel="nofollow" target="_blank" href="https://github.com/SUSE/doc-sle/edit/main/xml/hardware_nvdimm.xml" title="Edit the source file for this section">Edit source</a></h3><div class="doc-status"><ul><li><span class="ds-label">File Name: </span>hardware_nvdimm.xml</li><li><span class="ds-label">ID: </span>sec-nvdimm-setup-btt</li></ul></div></div></div></div><p>
     BTT provides sector write atomicity, which makes it a good choice
     when you need data protection, , for Ext4 and XFS journals.
     If there is a power failure, the journals
     are protected and should be recoverable. The following examples
     show how to create a PMEM namespace with BTT in sector mode, and how
     to place the file system journal in this namespace.
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root"># </code><code class="command">ndctl create-namespace --type=pmem --mode=sector</code>
{
 "dev":"namespace3.0",
 "mode":"sector",
 "uuid":"51ab652d-7f20-44ea-b51d-5670454f8b9b",
 "sector_size":4096,
 "blockdev":"pmem3s"
}</pre></div><p>
    Next, verify that the new device is present:
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root"># </code><code class="command">fdisk -l /dev/<em class="replaceable ">pmem3s</em></code>
Disk /dev/pmem3s: 188.8 GiB, 202738135040 bytes, 49496615 sectors
Units: sectors of 1 * 4096 = 4096 bytes
Sector size (logical/physical): 4096 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes</pre></div><p>
    Like the DAX-capable PMEM namespace we previously configured, this
    BTT-capable PMEM namespace consumes all the available storage on the
    NVDIMMs.
   </p><div id="id-1.3.7.6.7.4.7" class="admonition note normal"><img class="symbol" alt="Note" title="Note" src="static/images/icon-note.svg" /><h6>Note</h6><p>
     The trailing <code class="literal">s</code> in the device name
     (<code class="filename">/dev/<em class="replaceable ">pmem3s</em></code>) stands for
     <code class="literal">sector</code> and can be used to easily distinguish namespaces
     that are configured to use the BTT.
    </p></div><p>
    The volume can be formatted and mounted as in the previous example.
   </p><p>
    The PMEM namespace shown here cannot use DAX. Instead it uses the BTT to
    provide <span class="emphasis"><em>sector write atomicity</em></span>. On each sector write
    through the PMEM block driver, the BTT will allocate a new sector to
    receive the new data. The BTT atomically updates its internal mapping
    structures after the new data is fully written so the newly written data
    will be available to applications. If the power fails at any point during
    this process, the write will be lost and the application will
    have access to its old data, still intact. This prevents the condition
    known as <span class="quote">“<span class="quote ">torn sectors</span>”</span>.
   </p><p>
    This BTT-enabled PMEM namespace can be formatted and used with a file system
    same as any other standard block device. It cannot be used with DAX.
    However, <code class="literal">mmap</code> mappings for files on this block device
    will use the page cache.
   </p></div><div class="sect2 " id="sec-nvdimm-fs-journal"><div class="titlepage"><div><div><h3 class="title"><span class="number">19.5.4 </span><span xmlns:dm="urn:x-suse:ns:docmanager" class="name">Placing the file system journal on PMEM/BTT</span> <a title="Permalink" class="permalink" href="cha-nvdimm.html#sec-nvdimm-fs-journal">#</a><a class="report-bug" rel="nofollow" target="_blank" href="https://github.com/SUSE/doc-sle/edit/main/xml/hardware_nvdimm.xml" title="Edit the source file for this section">Edit source</a></h3><div class="doc-status"><ul><li><span class="ds-label">File Name: </span>hardware_nvdimm.xml</li><li><span class="ds-label">ID: </span>sec-nvdimm-fs-journal</li></ul></div></div></div></div><p>
      When you place the file system journal on a separate device, it
      must use the same file system block size as the file system. Most
      likely this is 4096, and you can find the block size with this
      command:
  </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root"># </code><code class="command">blockdev --getbsz /dev/<em class="replaceable ">sda3</em></code></pre></div><p>
      The following example creates a new Ext4 journal on a separate
      NVDIMM device, creates the file system on a SATA device, then
      attaches the new file system to the journal:
 </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root"># </code><code class="command">mke2fs -b 4096 -O journal_dev /dev/<em class="replaceable ">pmem3s</em></code>
<code class="prompt root"># </code><code class="command">mkfs.ext4 -J device=/dev/<em class="replaceable ">pmem3s</em> /dev/<em class="replaceable ">sda3</em></code></pre></div><p>
      The following example creates a new XFS file system on a SATA drive,
      and creates the journal on a separate NVDIMM device:
  </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root"># </code><code class="command">mkfs.xfs -l logdev=/dev/<em class="replaceable ">pmem3s </em> /dev/<em class="replaceable ">sda3</em></code></pre></div><p>
    See <code class="command">man 8 mkfs.ext4</code> and <code class="command">man 8 mkfs.ext4</code> for detailed information about options.
</p></div></div><div class="sect1 " id="sec-nvdimm-moreinfo"><div class="titlepage"><div><div><h2 class="title"><span class="number">19.6 </span><span xmlns:dm="urn:x-suse:ns:docmanager" class="name">More information</span> <a title="Permalink" class="permalink" href="cha-nvdimm.html#sec-nvdimm-moreinfo">#</a><a class="report-bug" rel="nofollow" target="_blank" href="https://github.com/SUSE/doc-sle/edit/main/xml/hardware_nvdimm.xml" title="Edit the source file for this section">Edit source</a></h2><div class="doc-status"><ul><li><span class="ds-label">File Name: </span>hardware_nvdimm.xml</li><li><span class="ds-label">ID: </span>sec-nvdimm-moreinfo</li></ul></div></div></div></div><p>
   More about this topic can be found in the following list:
  </p><div class="itemizedlist "><ul class="itemizedlist"><li class="listitem "><p>
     <a class="link" href="https://nvdimm.wiki.kernel.org/" target="_blank">
      Persistent Memory Wiki</a>
    </p><p>
     Contains instructions for configuring NVDIMM systems, information about
     testing, and links to specifications related to NVDIMM enabling. This site
     is developing as NVDIMM support in Linux is developing.
    </p></li><li class="listitem "><p>
     <a class="link" href="https://pmem.io/" target="_blank">Persistent Memory Programming</a>
    </p><p>
     Information about configuring, using and programming systems with
     non-volatile memory under Linux and other operating systems. Covers the
     NVM Library (NVML), which aims to provide useful APIs for programming with
     persistent memory in user space.
    </p></li><li class="listitem "><p>
     <a class="link" href="https://www.kernel.org/doc/Documentation/nvdimm/nvdimm.txt" target="_blank">
      LIBNVDIMM: Non-Volatile Devices</a>
    </p><p>
     Aimed at kernel developers, this is part of the Documentation directory in
     the current Linux kernel tree. It talks about the different kernel modules
     involved in NVDIMM enablement, lays out technical details of the
     kernel implementation, and talks about the
     <code class="filename">sysfs</code>interface to the kernel that is used by the
     <code class="command">ndctl</code> tool.
    </p></li><li class="listitem "><p>
     <a class="link" href="https://github.com/pmem/ndctl" target="_blank">GitHub: pmem/ndctl</a>
    </p><p>
     Utility library for managing the <code class="command">libnvdimm</code> subsystem
     in the Linux kernel. Also contains user space libraries, as well as unit
     tests and documentation.
    </p></li></ul></div></div></div></div><div class="page-bottom"><div id="_bottom-navigation"><a class="nav-link" href="part-help.html"><span class="next-icon">→</span><span class="nav-label"><span class="number">Part VI </span>Help and troubleshooting</span></a><a class="nav-link" href="sec-yast-hw-scan.html"><span class="prev-icon">←</span><span class="nav-label"><span class="number">Chapter 18 </span>Setting up a scanner</span></a></div><div class="_share-print"><div class="online-contents share"><strong>Share this page: </strong><span class="share-buttons"><span class="_share-fb bottom-button">Facebook</span><span class="spacer"> • </span><span class="_share-in bottom-button">LinkedIn</span><span class="spacer"> • </span><span class="_share-tw bottom-button">Twitter</span><span class="spacer"> • </span><span class="_share-mail bottom-button">E-Mail</span></span></div><div class="print"><span class="_print-button bottom-button">Print this page</span></div><div class="clearme"></div></div></div></div><div id="_inward"></div></div><div id="_footer-wrap"><div id="_footer"><p>©
        2024 
        SUSE</p><ul><li><a href="https://jobs.suse.com/" target="_top">Careers</a></li><li><a href="https://www.suse.com/company/legal/" target="_top">Legal</a></li><li><a href="https://www.suse.com/company/about/" target="_top">About</a></li><li><a href="https://www.suse.com/contact/" target="_top">Contact Us</a></li></ul></div></div></body></html>