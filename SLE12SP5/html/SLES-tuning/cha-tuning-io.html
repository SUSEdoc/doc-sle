<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>SLES 12 SP5 | System Analysis and Tuning Guide | Tuning I/O Performance</title><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"/><link rel="stylesheet" type="text/css" href="static/css/style.css"/>
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/"/>
<meta name="title" content="Tuning I/O Performance | SLES 12 SP5"/>
<meta name="description" content="I/O scheduling controls how input/output operations will be submitted to storage. SUSE Linux Enterprise Server offers various I/O algorithms—called e…"/>
<meta name="product-name" content="SUSE Linux Enterprise Server"/>
<meta name="product-number" content="12 SP5"/>
<meta name="book-title" content="System Analysis and Tuning Guide"/>
<meta name="chapter-title" content="Chapter 12. Tuning I/O Performance"/>
<meta name="tracker-url" content="https://bugzilla.suse.com/enter_bug.cgi"/>
<meta name="tracker-type" content="bsc"/>
<meta name="tracker-bsc-assignee" content="fs@suse.com"/>
<meta name="tracker-bsc-component" content="Documentation"/>
<meta name="tracker-bsc-product" content="SUSE Linux Enterprise Server 12 SP5"/>
<meta name="publisher" content="SUSE"/><meta property="og:title" content="System Analysis and Tuning Guide"/>
<meta property="og:description" content="Analyze and tune SLES systems"/>
<meta property="og:type" content="article"/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="System Analysis and Tuning Guide"/>
<meta name="twitter:description" content="Analyze and tune SLES systems"/>
<script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": ["TechArticle"],
    "image": "https://www.suse.com/assets/img/suse-white-logo-green.svg",
    
     "isPartOf": {
      "@type": "CreativeWorkSeries",
      "name": "Products &amp; Solutions"
    },
    
    "inLanguage": "en",
    

    "headline": "Tuning I/O Performance",
  
    "description": "Tuning I/O Performance",
      
    "author": [
      {
        "@type": "Corporation",
        "name": "SUSE Product &amp; Solution Documentation Team",
        "url": "https://www.suse.com/assets/img/suse-white-logo-green.svg"
      }
    ],
      
    "dateModified": "2019-12-09T00:00+02:00",
      
    "datePublished": "2019-12-09T00:00+02:00",
      

    "about": [
      
    ],
  
    "sameAs": [
          "https://www.facebook.com/SUSEWorldwide/about",
          "https://www.youtube.com/channel/UCHTfqIzPKz4f_dri36lAQGA",
          "https://twitter.com/SUSE",
          "https://www.linkedin.com/company/suse"
    ],
    "publisher": {
      "@type": "Corporation",
      "name": "SUSE",
      "url": "https://documentation.suse.com",
      "logo": {
        "@type": "ImageObject",
        "url": "https://www.suse.com/assets/img/suse-white-logo-green.svg"
      }
    }
  }</script>
<link rel="prev" href="part-tuning-kernel.html" title="Part V. Kernel Tuning"/><link rel="next" href="cha-tuning-taskscheduler.html" title="Chapter 13. Tuning the Task Scheduler"/><script type="text/javascript">

if ( window.location.protocol.toLowerCase() != 'file:' ) {
  document.write('<link rel="stylesheet" type="text/css" href="https://documentation.suse.com/docserv/res/fonts/poppins/poppins.css"></link>');
};

</script><noscript><link rel="stylesheet" type="text/css" href="https://documentation.suse.com/docserv/res/fonts/poppins/poppins.css"/></noscript><script src="static/js/script-purejs.js" type="text/javascript"> </script><script src="static/js/highlight.min.js" type="text/javascript"> </script><script>

$(document).ready(function() {
  $('.verbatim-wrap.highlight').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});
hljs.configure({
  useBR: false
});

</script><meta name="edit-url" content="https://github.com/SUSE/doc-sle/edit/maintenance/SLE12SP5/xml/tuning_storagescheduler.xml"/></head><body class="draft wide offline js-off" onload="$('#betawarn-button-wrap').toggle();if (document.cookie.length > 0) {if (document.cookie.indexOf('betawarn=closed') != -1){$('#betawarn').toggle()}};"><div id="betawarn" style="position:fixed;bottom:0;z-index:9025;background-color:#FDE8E8;padding:1em;margin-left:10%;margin-right:10%;display:block;border-top:.75em solid #E11;width:80%"><p style="color:#333;margin:1em 0;padding:0;">This is a draft document that was built and uploaded automatically. It may document beta software and be incomplete or even incorrect. <strong>Use this document at your own risk.</strong></p> <div id="betawarn-button-wrap" style="display:none;margin:0;padding:0;"><a href="#" onclick="$('#betawarn').toggle();var d=new Date();d.setTime(d.getTime()+(0.5*24*60*60*1000));document.cookie='betawarn=closed; expires='+d.toUTCString()+'; path=/'; return false;" style="color:#333;text-decoration:underline;float:left;margin-top:.5em;padding:1em;display:block;background-color:#FABEBE;">I understand this is a draft</a></div></div><div class="bypass-block"><a href="#_content">Jump to content</a><a href="#_bottom-pagination">Jump to page navigation: previous page [access key p]/next page [access key n]</a></div><header id="_mainnav"><div class="growth-inhibitor"><img src="static/images/logo.svg" alt="Logo" class="logo"/></div></header><div class="crumbs"><div class="growth-inhibitor"><a class="crumb" href="index.html">System Analysis and Tuning Guide</a><span> / </span><a class="crumb" href="part-tuning-kernel.html">Kernel Tuning</a><span> / </span><a class="crumb" href="cha-tuning-io.html">Tuning I/O Performance</a></div></div><main id="_content"><nav id="_side-toc-overall" class="side-toc"><div class="side-title">System Analysis and Tuning Guide</div><ol><li><a href="preface-tuning.html" class=" "><span class="title-number"> </span><span class="title-name">About This Guide</span></a></li><li><a href="part-tuning-basics.html" class="has-children "><span class="title-number">I </span><span class="title-name">Basics</span></a><ol><li><a href="cha-tuning-basics.html" class=" "><span class="title-number">1 </span><span class="title-name">General Notes on System Tuning</span></a></li></ol></li><li><a href="part-tuning-monitoring.html" class="has-children "><span class="title-number">II </span><span class="title-name">System Monitoring</span></a><ol><li><a href="cha-util.html" class=" "><span class="title-number">2 </span><span class="title-name">System Monitoring Utilities</span></a></li><li><a href="cha-tuning-logfiles.html" class=" "><span class="title-number">3 </span><span class="title-name">Analyzing and Managing System Log Files</span></a></li></ol></li><li><a href="part-tuning-kerneltrace.html" class="has-children "><span class="title-number">III </span><span class="title-name">Kernel Monitoring</span></a><ol><li><a href="cha-tuning-systemtap.html" class=" "><span class="title-number">4 </span><span class="title-name">SystemTap—Filtering and Analyzing System Data</span></a></li><li><a href="cha-tuning-kprobes.html" class=" "><span class="title-number">5 </span><span class="title-name">Kernel Probes</span></a></li><li><a href="cha-perf.html" class=" "><span class="title-number">6 </span><span class="title-name">Hardware-Based Performance Monitoring with Perf</span></a></li><li><a href="cha-tuning-oprofile.html" class=" "><span class="title-number">7 </span><span class="title-name">OProfile—System-Wide Profiler</span></a></li></ol></li><li><a href="part-tuning-resources.html" class="has-children "><span class="title-number">IV </span><span class="title-name">Resource Management</span></a><ol><li><a href="cha-tuning-resources.html" class=" "><span class="title-number">8 </span><span class="title-name">General System Resource Management</span></a></li><li><a href="cha-tuning-cgroups.html" class=" "><span class="title-number">9 </span><span class="title-name">Kernel Control Groups</span></a></li><li><a href="cha-tuning-numactl.html" class=" "><span class="title-number">10 </span><span class="title-name">Automatic Non-Uniform Memory Access (NUMA) Balancing</span></a></li><li><a href="cha-tuning-power.html" class=" "><span class="title-number">11 </span><span class="title-name">Power Management</span></a></li></ol></li><li class="active"><a href="part-tuning-kernel.html" class="has-children you-are-here"><span class="title-number">V </span><span class="title-name">Kernel Tuning</span></a><ol><li><a href="cha-tuning-io.html" class=" you-are-here"><span class="title-number">12 </span><span class="title-name">Tuning I/O Performance</span></a></li><li><a href="cha-tuning-taskscheduler.html" class=" "><span class="title-number">13 </span><span class="title-name">Tuning the Task Scheduler</span></a></li><li><a href="cha-tuning-memory.html" class=" "><span class="title-number">14 </span><span class="title-name">Tuning the Memory Management Subsystem</span></a></li><li><a href="cha-tuning-network.html" class=" "><span class="title-number">15 </span><span class="title-name">Tuning the Network</span></a></li></ol></li><li><a href="part-tuning-dumps.html" class="has-children "><span class="title-number">VI </span><span class="title-name">Handling System Dumps</span></a><ol><li><a href="cha-tuning-tracing.html" class=" "><span class="title-number">16 </span><span class="title-name">Tracing Tools</span></a></li><li><a href="cha-tuning-kexec.html" class=" "><span class="title-number">17 </span><span class="title-name">Kexec and Kdump</span></a></li><li><a href="cha-tuning-systemd-coredump.html" class=" "><span class="title-number">18 </span><span class="title-name">Using <code class="systemitem">systemd-coredump</code> to Debug Application Crashes</span></a></li></ol></li><li><a href="part-tuning-ptp.html" class="has-children "><span class="title-number">VII </span><span class="title-name">Synchronized Clocks with Precision Time Protocol</span></a><ol><li><a href="cha-tuning-ptp.html" class=" "><span class="title-number">19 </span><span class="title-name">Precision Time Protocol</span></a></li></ol></li><li><a href="bk06apa.html" class=" "><span class="title-number">A </span><span class="title-name">GNU licenses</span></a></li> </ol> </nav><button id="_open-side-toc-overall" title="Contents"> </button><article class="documentation"><button id="_unfold-side-toc-page">On this page</button><section class="chapter" id="cha-tuning-io" data-id-title="Tuning I/O Performance"><div class="titlepage"><div><div class="version-info">Applies to  <span class="productname"><span class="productname"><span class="phrase">SUSE Linux Enterprise Server</span></span></span> <span class="productnumber"><span class="productnumber">12 SP5</span></span></div><div><div class="title-container"><h1 class="title"><span class="title-number-name"><span class="title-number">12 </span><span class="title-name">Tuning I/O Performance</span></span> <a title="Permalink" class="permalink" href="cha-tuning-io.html#">#</a></h1><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-sle/edit/maintenance/SLE12SP5/xml/tuning_storagescheduler.xml" title="Edit source document"> </a></div></div></div></div></div><p>
  I/O scheduling controls how input/output operations will be submitted to
  storage. <span class="productname"><span class="phrase">SUSE Linux Enterprise Server</span></span> offers various I/O algorithms—called
  <code class="literal">elevators</code>—suiting different workloads. Elevators can
  help to reduce seek operations and can prioritize I/O requests.
 </p><p>
  Choosing the best suited I/O elevator not only depends on the workload, but
  on the hardware, too. Single ATA disk systems, SSDs, RAID arrays, or network
  storage systems, for example, each require different tuning strategies.
 </p><section class="sect1" id="cha-tuning-io-switch" data-id-title="Switching I/O Scheduling"><div class="titlepage"><div><div><div class="title-container"><h2 class="title"><span class="title-number-name"><span class="title-number">12.1 </span><span class="title-name">Switching I/O Scheduling</span></span> <a title="Permalink" class="permalink" href="cha-tuning-io.html#cha-tuning-io-switch">#</a></h2><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-sle/edit/maintenance/SLE12SP5/xml/tuning_storagescheduler.xml" title="Edit source document"> </a></div></div></div></div></div><p>
   <span class="productname"><span class="phrase">SUSE Linux Enterprise Server</span></span> picks a default I/O scheduler at boot-time, which can be
   changed on the fly per block device. This makes it possible to set different
   algorithms, for example, for the device hosting the system partition and the
   device hosting a database.
  </p><p>
   The default I/O scheduler is chosen for each device based on whether the
   device reports to be rotational disk or not. For non-rotational disks
   <code class="systemitem">DEADLINE</code> I/O scheduler is picked.
   Other devices default to <code class="systemitem">CFQ</code>
   (Completely Fair Queuing). To change this default, use the following boot
   parameter:
  </p><div class="verbatim-wrap"><pre class="screen">elevator=<em class="replaceable">SCHEDULER</em></pre></div><p>
   Replace <em class="replaceable">SCHEDULER</em> with one of the values
   <code class="option">cfq</code>, <code class="option">noop</code>, or <code class="option">deadline</code>.
   See <a class="xref" href="cha-tuning-io.html#cha-tuning-io-schedulers" title="12.2. Available I/O Elevators">Section 12.2, “Available I/O Elevators”</a> for details.
  </p><p>
   To change the elevator for a specific device in the running system, run the
   following command:
  </p><div class="verbatim-wrap"><pre class="screen">echo <em class="replaceable">SCHEDULER</em> &gt; /sys/block/<em class="replaceable">DEVICE</em>/queue/scheduler</pre></div><p>
   Here, <em class="replaceable">SCHEDULER</em> is one of <code class="option">cfq</code>,
   <code class="option">noop</code>, or <code class="option">deadline</code>.
   <em class="replaceable">DEVICE</em> is the block device
   (<code class="systemitem">sda</code> for example). Note that this change will not
   persist during reboot. For permanent I/O scheduler change for a particular
   device either place the command switching the I/O scheduler into init
   scripts or add appropriate udev rule into
   <code class="filename">/lib/udev/rules.d/</code>. See
   <code class="filename">/lib/udev/rules.d/60-ssd-scheduler.rules</code> for an example
   of such tuning.
  </p><div id="id-1.8.7.2.5.9" data-id-title="Default Scheduler on IBM IBM Z" class="admonition note normal"><img class="symbol" alt="Note" title="Note" src="static/images/icon-note.svg"/><div class="admon-title">Note: Default Scheduler on IBM IBM Z</div><p>
    On IBM IBM Z, the default I/O scheduler for a storage device is set by
    the device driver.
   </p></div><div id="id-1.8.7.2.5.10" data-id-title="Scheduler in case of block multi-queue (blk-mq) I/O path" class="admonition note normal"><img class="symbol" alt="Note" title="Note" src="static/images/icon-note.svg"/><div class="admon-title">Note: Scheduler in case of block multi-queue (blk-mq) I/O path</div><p>
     The <code class="literal">elevator</code> boot parameter does not apply to
     devices using blk-mq I/O path (refer to <a class="xref" href="cha-tuning-io.html#cha-tuning-io-scsimq" title="12.5. Enable blk-mq I/O Path for SCSI by Default">Section 12.5, “Enable blk-mq I/O Path for SCSI by Default”</a>).
   </p><p>
     Default elevator is <code class="option">mq-deadline</code> for conventional
     devices (for example, regular hard disks, SSDs) and
     <code class="option">none</code> for faster storage devices (devices with
     multiple hardware queues).
   </p><p>
     It is possible to change the elevator for a specific device in a running
     system. <em class="replaceable">SCHEDULER</em> should be set to either
     <code class="option">mq-deadline</code>, <code class="option">kyber</code>,
     <code class="option">bfq</code>, or <code class="option">none</code>
   </p></div></section><section class="sect1" id="cha-tuning-io-schedulers" data-id-title="Available I/O Elevators"><div class="titlepage"><div><div><div class="title-container"><h2 class="title"><span class="title-number-name"><span class="title-number">12.2 </span><span class="title-name">Available I/O Elevators</span></span> <a title="Permalink" class="permalink" href="cha-tuning-io.html#cha-tuning-io-schedulers">#</a></h2><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-sle/edit/maintenance/SLE12SP5/xml/tuning_storagescheduler.xml" title="Edit source document"> </a></div></div></div></div></div><p>
   Below is a list of elevators available on <span class="productname"><span class="phrase">SUSE Linux Enterprise Server</span></span> for devices that use
   the legacy block I/O path. If an elevator has tunable parameters, they can
   be set with the command:
  </p><div class="verbatim-wrap"><pre class="screen">echo <em class="replaceable">VALUE</em> &gt; /sys/block/<em class="replaceable">DEVICE</em>/queue/iosched/<em class="replaceable">TUNABLE</em></pre></div><p>
   where <em class="replaceable">VALUE</em> is the desired value for the
   <em class="replaceable">TUNABLE</em> and <em class="replaceable">DEVICE</em> the
   block device.
  </p><p>
   To find out what elevators are available for a device
   (<code class="systemitem">sda</code> for example), run the following command (the
   currently selected scheduler is listed in brackets):
  </p><div class="verbatim-wrap"><pre class="screen">jupiter:~ # cat /sys/block/sda/queue/scheduler
noop deadline [cfq]</pre></div><p>
   This file can also contain the string <code class="literal">none</code> meaning that
   I/O scheduling does not happen for this device. This is usually because the
   device uses a multi-queue queuing mechanism (refer to
   <a class="xref" href="cha-tuning-io.html#cha-tuning-io-scsimq" title="12.5. Enable blk-mq I/O Path for SCSI by Default">Section 12.5, “Enable blk-mq I/O Path for SCSI by Default”</a>).
  </p><section class="sect2" id="sec-tuning-io-schedulers-cfq" data-id-title="CFQ (Completely Fair Queuing)"><div class="titlepage"><div><div><div class="title-container"><h3 class="title"><span class="title-number-name"><span class="title-number">12.2.1 </span><span class="title-name"><code class="systemitem">CFQ</code> (Completely Fair Queuing)</span></span> <a title="Permalink" class="permalink" href="cha-tuning-io.html#sec-tuning-io-schedulers-cfq">#</a></h3><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-sle/edit/maintenance/SLE12SP5/xml/tuning_storagescheduler.xml" title="Edit source document"> </a></div></div></div></div></div><p>
    <code class="systemitem">CFQ</code> is a fairness-oriented
    scheduler and is used by default on <span class="productname"><span class="phrase">SUSE Linux Enterprise Server</span></span>. The algorithm assigns
    each thread a time slice in which it is allowed to submit I/O to disk. This
    way each thread gets a fair share of I/O throughput. It also allows
    assigning tasks I/O priorities which are taken into account during
    scheduling decisions (see
    <a class="xref" href="cha-tuning-resources.html#cha-tuning-resources-disk-ionice" title="8.3.3. Prioritizing Disk Access with ionice">Section 8.3.3, “Prioritizing Disk Access with <code class="command">ionice</code>”</a>). The
    <code class="systemitem">CFQ</code> scheduler has the following
    tunable parameters:
   </p><div class="table" id="tab-tunables-cfq" data-id-title="CFQ tunable parameters"><div class="title-container"><div class="table-title-wrap"><div class="table-title"><span class="title-number-name"><span class="title-number">Table 12.1: </span><span class="title-name"><code class="systemitem">CFQ</code> tunable parameters </span></span><a title="Permalink" class="permalink" href="cha-tuning-io.html#tab-tunables-cfq">#</a></div></div><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-sle/edit/maintenance/SLE12SP5/xml/tuning_storagescheduler.xml" title="Edit source document"> </a></div></div><div class="table-contents"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col class="1"/><col class="2"/></colgroup><thead><tr><th style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         File
        </p>
       </th><th style="border-bottom: 1px solid ; ">
        <p>
         Description
        </p>
       </th></tr></thead><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">slice_idle</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         When a task has no more I/O to submit in its time slice, the I/O
         scheduler waits before scheduling the next thread.
         <code class="filename">slice_idle</code> specifies the I/O scheduler's waiting
         time in milliseconds. Waiting for more I/O from a thread can improve
         locality of I/O. Additionally, it avoids starving processes doing
         dependent I/O. A process does dependent I/O if it needs a result of
         one I/O to submit another I/O. For example, if you first need to read
         an index block to find out a data block to read, these two reads form
         a dependent I/O.
        </p>
        <p>
         For media where locality is less important (SSDs, SANs with lots of
         disks), setting <code class="filename">slice_idle</code> to
         <code class="literal">0</code> can improve the throughput considerably.
        </p>
        <p>
         Default is <code class="literal">8</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">slice_idle_us</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Same as <code class="filename">slice_idle</code> but in microseconds.
        </p>
        <p>
         Default is <code class="literal">8000</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">quantum</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         This option limits the maximum number of requests that are being
         processed by the device. For a storage with several disks, this
         setting can unnecessarily limit parallel processing of requests.
         Therefore, increasing the value can improve performance. However, it
         can also cause latency of certain I/O operations to increase, because
         more requests are buffered inside the storage. When changing this
         value, you can also consider tuning
         <code class="filename">slice_async_rq</code>.
        </p>
        <p>
         Default is <code class="literal">8</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">low_latency</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         When enabled (which is the default on <span class="productname"><span class="phrase">SUSE Linux Enterprise Server</span></span>), the scheduler
         may dynamically adjust the length of the time slice by aiming to meet
         a tuning parameter called the <code class="filename">target_latency</code>.
         Time slices are recomputed to meet this
         <code class="filename">target_latency</code> and ensure that processes get fair
         access within a bounded length of time.
        </p>
        <p>
         Default is <code class="literal">1</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">target_latency</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Contains an estimated latency time in milliseconds for
         <code class="systemitem">CFQ</code>.
         <code class="systemitem">CFQ</code> uses it to calculate
         the time slice used for every task.
        </p>
        <p>
         Default is <code class="literal">300</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">target_latency_us</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Same as <code class="filename">target_latency</code> but in microseconds.
        </p>
        <p>
         Default is <code class="literal">300000</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">group_idle</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         To avoid starving of blkio cgroups doing dependent I/O,
         <code class="systemitem">CFQ</code> pauses after
         completion of I/O for one blkio cgroup before scheduling I/O for a
         different blkio cgroup. <code class="filename">group_idle</code> specifies the
         time in milliseconds the I/O scheduler waits. When
         <code class="filename">slice_idle</code> is set, this parameter does not have a
         significant effect. However, for fast media, the overhead of
         <code class="filename">slice_idle</code> is generally undesirable. Disabling
         <code class="filename">slice_idle</code> and setting
         <code class="filename">group_idle</code> is a method to avoid starvation of
         blkio cgroups doing dependent I/O with lower overhead.
        </p>
        <p>
         Default is <code class="literal">8</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">group_idle_us</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Same as <code class="filename">group_idle</code> but in microseconds.
        </p>
        <p>
         Default is <code class="literal">8000</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">slice_sync</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         This parameter is used to calculate the time slice for synchronous
         queue. It is specified in milliseconds. Increasing this value
         increases the time slice of synchronous queue.
        </p>
        <p>
         Default is <code class="literal">100</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">slice_sync_us</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Same as <code class="filename">slice_sync</code> but in microseconds.
        </p>
        <p>
         Default is <code class="literal">100000</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">slice_async</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         This parameter is used to calculate the time slice for asynchronous
         queue. It is specified in milliseconds. Increasing this value
         increases the time slice of asynchronous queue.
        </p>
        <p>
         Default is <code class="literal">40</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">slice_async_us</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Same as <code class="filename">slice_async</code> but in microseconds.
        </p>
        <p>
         Default is <code class="literal">40000</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">slice_async_rq</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         This limits the maximum number of asynchronous requests—usually
         write requests—that are submitted in one time slice.
        </p>
        <p>
         Default is <code class="literal">2</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">back_seek_max</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Maximum "distance" (in Kbytes) for backward seeking.
        </p>
        <p>
         Default is <code class="literal">16384</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">back_seek_penalty</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Used to compute the cost of backward seeking.
        </p>
        <p>
         Default is <code class="literal">2</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">fifo_expire_async</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Value (in milliseconds) is used to set the timeout of asynchronous
         requests.
        </p>
        <p>
         Default is <code class="literal">250</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; ">
        <p>
         <code class="filename">fifo_expire_sync</code>
        </p>
       </td><td>
        <p>
         Value (in milliseconds) that specifies the timeout of synchronous
         requests.
        </p>
        <p>
         Default is <code class="literal">125</code>.
        </p>
       </td></tr></tbody></table></div></div><div class="complex-example"><div class="example" id="id-1.8.7.2.6.8.4" data-id-title="Increasing individual thread throughput using CFQ"><div class="title-container"><div class="example-title-wrap"><div class="example-title"><span class="title-number-name"><span class="title-number">Example 12.1: </span><span class="title-name">Increasing individual thread throughput using <code class="systemitem">CFQ</code> </span></span><a title="Permalink" class="permalink" href="cha-tuning-io.html#id-1.8.7.2.6.8.4">#</a></div></div><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-sle/edit/maintenance/SLE12SP5/xml/tuning_storagescheduler.xml" title="Edit source document"> </a></div></div><div class="example-contents"><p>
     In <span class="productname"><span class="phrase">SUSE Linux Enterprise Server</span></span> <span class="productnumber">12 SP5</span>, the <code class="literal">low_latency</code>
     tuning parameter is enabled by default to ensure that processes get fair
     access within a bounded length of time. (Note that this parameter was not
     enabled in versions prior to <span class="phrase">SUSE Linux Enterprise
     12</span>.)
    </p><p>
     This is usually preferred in a server scenario where processes are
     executing I/O as part of transactions, as it makes the time needed for
     each transaction predictable. However, there are scenarios where that is
     not the desired behavior:
    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
       If the performance metric of interest is the peak performance of a
       single process when there is I/O contention.
      </p></li><li class="listitem"><p>
       If a workload must complete as quickly as possible and there are
       multiple sources of I/O. In this case, unfair treatment from the I/O
       scheduler may allow the transactions to complete faster: Processes take
       their full slice and exit quickly, resulting in reduced overall
       contention.
      </p></li></ul></div><p>
     To address this, there are two options—increase
     <code class="literal">target_latency</code> or disable
     <code class="literal">low_latency</code>. As with all tuning parameters it is
     important to verify your workload behaves as expected before and after the
     tuning modification. Take careful note of whether your workload depends on
     individual process peak performance or scales better with fairness. It
     should also be noted that the performance will depend on the underlying
     storage and the correct tuning option for one installation may not be
     universally true.
    </p><p>
     Find below an example that does not control when I/O starts but is simple
     enough to demonstrate the point. 32 processes are writing a small amount
     of data to disk in parallel. Using the <span class="productname"><span class="phrase">SUSE Linux Enterprise Server</span></span> default (enabling
     <code class="literal">low_latency</code>), the result looks as follows:
    </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code>echo 1 &gt; /sys/block/sda/queue/iosched/low_latency
<code class="prompt root">root # </code>time ./dd-test.sh
10485760 bytes (10 MB) copied, 2.62464 s, 4.0 MB/s
10485760 bytes (10 MB) copied, 3.29624 s, 3.2 MB/s
10485760 bytes (10 MB) copied, 3.56341 s, 2.9 MB/s
10485760 bytes (10 MB) copied, 3.56908 s, 2.9 MB/s
10485760 bytes (10 MB) copied, 3.53043 s, 3.0 MB/s
10485760 bytes (10 MB) copied, 3.57511 s, 2.9 MB/s
10485760 bytes (10 MB) copied, 3.53672 s, 3.0 MB/s
10485760 bytes (10 MB) copied, 3.5433 s, 3.0 MB/s
10485760 bytes (10 MB) copied, 3.65474 s, 2.9 MB/s
10485760 bytes (10 MB) copied, 3.63694 s, 2.9 MB/s
10485760 bytes (10 MB) copied, 3.90122 s, 2.7 MB/s
10485760 bytes (10 MB) copied, 3.88507 s, 2.7 MB/s
10485760 bytes (10 MB) copied, 3.86135 s, 2.7 MB/s
10485760 bytes (10 MB) copied, 3.84553 s, 2.7 MB/s
10485760 bytes (10 MB) copied, 3.88871 s, 2.7 MB/s
10485760 bytes (10 MB) copied, 3.94943 s, 2.7 MB/s
10485760 bytes (10 MB) copied, 4.12731 s, 2.5 MB/s
10485760 bytes (10 MB) copied, 4.15106 s, 2.5 MB/s
10485760 bytes (10 MB) copied, 4.21601 s, 2.5 MB/s
10485760 bytes (10 MB) copied, 4.35004 s, 2.4 MB/s
10485760 bytes (10 MB) copied, 4.33387 s, 2.4 MB/s
10485760 bytes (10 MB) copied, 4.55434 s, 2.3 MB/s
10485760 bytes (10 MB) copied, 4.52283 s, 2.3 MB/s
10485760 bytes (10 MB) copied, 4.52682 s, 2.3 MB/s
10485760 bytes (10 MB) copied, 4.56176 s, 2.3 MB/s
10485760 bytes (10 MB) copied, 4.62727 s, 2.3 MB/s
10485760 bytes (10 MB) copied, 4.78958 s, 2.2 MB/s
10485760 bytes (10 MB) copied, 4.79772 s, 2.2 MB/s
10485760 bytes (10 MB) copied, 4.78004 s, 2.2 MB/s
10485760 bytes (10 MB) copied, 4.77994 s, 2.2 MB/s
10485760 bytes (10 MB) copied, 4.86114 s, 2.2 MB/s
10485760 bytes (10 MB) copied, 4.88062 s, 2.1 MB/s

real    0m4.978s
user    0m0.112s
sys     0m1.544s</pre></div><p>
     Note that each process completes in similar times. This is the
     <code class="systemitem">CFQ</code> scheduler meeting its
     <code class="literal">target_latency</code>: Each process has fair access to
     storage.
    </p><p>
     Note that the earlier processes complete somewhat faster. This happens
     because the start time of the processes is not identical. In a more
     complicated example, it is possible to control for this.
    </p><p>
     This is what happens when low_latency is disabled:
    </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt root">root # </code>echo 0 &gt; /sys/block/sda/queue/iosched/low_latency
<code class="prompt root">root # </code>time ./dd-test.sh
10485760 bytes (10 MB) copied, 0.813519 s, 12.9 MB/s
10485760 bytes (10 MB) copied, 0.788106 s, 13.3 MB/s
10485760 bytes (10 MB) copied, 0.800404 s, 13.1 MB/s
10485760 bytes (10 MB) copied, 0.816398 s, 12.8 MB/s
10485760 bytes (10 MB) copied, 0.959087 s, 10.9 MB/s
10485760 bytes (10 MB) copied, 1.09563 s, 9.6 MB/s
10485760 bytes (10 MB) copied, 1.18716 s, 8.8 MB/s
10485760 bytes (10 MB) copied, 1.27661 s, 8.2 MB/s
10485760 bytes (10 MB) copied, 1.46312 s, 7.2 MB/s
10485760 bytes (10 MB) copied, 1.55489 s, 6.7 MB/s
10485760 bytes (10 MB) copied, 1.64277 s, 6.4 MB/s
10485760 bytes (10 MB) copied, 1.78196 s, 5.9 MB/s
10485760 bytes (10 MB) copied, 1.87496 s, 5.6 MB/s
10485760 bytes (10 MB) copied, 1.9461 s, 5.4 MB/s
10485760 bytes (10 MB) copied, 2.08351 s, 5.0 MB/s
10485760 bytes (10 MB) copied, 2.28003 s, 4.6 MB/s
10485760 bytes (10 MB) copied, 2.42979 s, 4.3 MB/s
10485760 bytes (10 MB) copied, 2.54564 s, 4.1 MB/s
10485760 bytes (10 MB) copied, 2.6411 s, 4.0 MB/s
10485760 bytes (10 MB) copied, 2.75171 s, 3.8 MB/s
10485760 bytes (10 MB) copied, 2.86162 s, 3.7 MB/s
10485760 bytes (10 MB) copied, 2.98453 s, 3.5 MB/s
10485760 bytes (10 MB) copied, 3.13723 s, 3.3 MB/s
10485760 bytes (10 MB) copied, 3.36399 s, 3.1 MB/s
10485760 bytes (10 MB) copied, 3.60018 s, 2.9 MB/s
10485760 bytes (10 MB) copied, 3.58151 s, 2.9 MB/s
10485760 bytes (10 MB) copied, 3.67385 s, 2.9 MB/s
10485760 bytes (10 MB) copied, 3.69471 s, 2.8 MB/s
10485760 bytes (10 MB) copied, 3.66658 s, 2.9 MB/s
10485760 bytes (10 MB) copied, 3.81495 s, 2.7 MB/s
10485760 bytes (10 MB) copied, 4.10172 s, 2.6 MB/s
10485760 bytes (10 MB) copied, 4.0966 s, 2.6 MB/s

real    0m3.505s
user    0m0.160s
sys     0m1.516s</pre></div><p>
     Note that the time processes take to complete is spread much wider as
     processes are not getting fair access. Some processes complete faster and
     exit, allowing the total workload to complete faster, and some processes
     measure higher apparent I/O performance. It is also important to note that
     this example may not behave similarly on all systems as the results depend
     on the resources of the machine and the underlying storage.
    </p><p>
     It is important to emphasize that neither tuning option is inherently
     better than the other. Both are best in different circumstances and it is
     important to understand the requirements of your workload and tune
     accordingly.
    </p></div></div></div></section><section class="sect2" id="sec-tuning-io-schedulers-noop" data-id-title="NOOP"><div class="titlepage"><div><div><div class="title-container"><h3 class="title"><span class="title-number-name"><span class="title-number">12.2.2 </span><span class="title-name"><code class="systemitem">NOOP</code></span></span> <a title="Permalink" class="permalink" href="cha-tuning-io.html#sec-tuning-io-schedulers-noop">#</a></h3><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-sle/edit/maintenance/SLE12SP5/xml/tuning_storagescheduler.xml" title="Edit source document"> </a></div></div></div></div></div><p>
    A trivial scheduler that only passes down the I/O that comes to it. Useful
    for checking whether complex I/O scheduling decisions of other schedulers
    are causing I/O performance regressions.
   </p><p>
    This scheduler is recommended for setups with devices that do I/O
    scheduling themselves, such as intelligent storage or in multipathing
    environments. If you choose a more complicated scheduler on the host, the
    scheduler of the host and the scheduler of the storage device compete with
    each other. This can decrease performance. The storage device can usually
    determine best how to schedule I/O.
   </p><p>
    For similar reasons, this scheduler is also recommended for use within
    virtual machines.
   </p><p>
    The <code class="systemitem">NOOP</code> scheduler can be useful
    for devices that do not depend on mechanical movement, like SSDs. Usually,
    the <code class="systemitem">DEADLINE</code> I/O scheduler is a
    better choice for these devices. However,
    <code class="systemitem">NOOP</code> creates less overhead and
    thus can on certain workloads increase performance.
   </p></section><section class="sect2" id="sec-tuning-io-schedulers-deadline" data-id-title="DEADLINE"><div class="titlepage"><div><div><div class="title-container"><h3 class="title"><span class="title-number-name"><span class="title-number">12.2.3 </span><span class="title-name"><code class="systemitem">DEADLINE</code></span></span> <a title="Permalink" class="permalink" href="cha-tuning-io.html#sec-tuning-io-schedulers-deadline">#</a></h3><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-sle/edit/maintenance/SLE12SP5/xml/tuning_storagescheduler.xml" title="Edit source document"> </a></div></div></div></div></div><p>
    <code class="systemitem">DEADLINE</code> is a latency-oriented
    I/O scheduler. Each I/O request is assigned a deadline. Usually, requests
    are stored in queues (read and write) sorted by sector numbers. The
    <code class="systemitem">DEADLINE</code> algorithm maintains two
    additional queues (read and write) in which requests are sorted by
    deadline. As long as no request has timed out, the <span class="quote">“<span class="quote">sector</span>”</span>
    queue is used. When timeouts occur, requests from the
    <span class="quote">“<span class="quote">deadline</span>”</span> queue are served until there are no more expired
    requests. Generally, the algorithm prefers reads over writes.
   </p><p>
    This scheduler can provide a superior throughput over the
    <code class="systemitem">CFQ</code> I/O scheduler in cases where
    several threads read and write and fairness is not an issue. For example,
    for several parallel readers from a SAN and for databases (especially when
    using <span class="quote">“<span class="quote">TCQ</span>”</span> disks). The
    <code class="systemitem">DEADLINE</code> scheduler has the
    following tunable parameters:
   </p><div class="table" id="tab-tunables-deadline" data-id-title="DEADLINE tunable parameters"><div class="title-container"><div class="table-title-wrap"><div class="table-title"><span class="title-number-name"><span class="title-number">Table 12.2: </span><span class="title-name"><code class="systemitem">DEADLINE</code> tunable parameters </span></span><a title="Permalink" class="permalink" href="cha-tuning-io.html#tab-tunables-deadline">#</a></div></div><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-sle/edit/maintenance/SLE12SP5/xml/tuning_storagescheduler.xml" title="Edit source document"> </a></div></div><div class="table-contents"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col class="1"/><col class="2"/></colgroup><thead><tr><th style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         File
        </p>
       </th><th style="border-bottom: 1px solid ; ">
        <p>
         Description
        </p>
       </th></tr></thead><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">writes_starved</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Controls how many times reads are preferred over writes. A value of
         <code class="literal">3</code> means that three read operations can be done
         before writes and reads are dispatched on the same selection criteria.
        </p>
        <p>
         Default is <code class="literal">3</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">read_expire</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Sets the deadline (current time plus the
         <code class="literal">read_expire</code> value) for read operations in
         milliseconds.
        </p>
        <p>
         Default is <code class="literal">500</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">write_expire</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Sets the deadline (current time plus the
         <code class="literal">write_expire</code> value) for write operations in
         milliseconds.
        </p>
        <p>
         Default is <code class="literal">5000</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">front_merges</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Enables (1) or disables (0) attempts to front merge requests.
        </p>
        <p>
         Default is <code class="literal">1</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; ">
        <p>
         <code class="filename">fifo_batch</code>
        </p>
       </td><td>
        <p>
         Sets the maximum number of requests per batch (deadline expiration is
         only checked for batches). This parameter allows to balance between
         latency and throughput. When set to <code class="literal">1</code> (that is, one
         request per batch), it results in "first come, first served" behaviour
         and usually lowest latency. Higher values usually increase throughput.
        </p>
        <p>
         Default is <code class="literal">16</code>.
        </p>
       </td></tr></tbody></table></div></div></section></section><section class="sect1" id="cha-tuning-io-schedulers-blkmq" data-id-title="Available I/O Elevators with blk-mq I/O path"><div class="titlepage"><div><div><div class="title-container"><h2 class="title"><span class="title-number-name"><span class="title-number">12.3 </span><span class="title-name">Available I/O Elevators with blk-mq I/O path</span></span> <a title="Permalink" class="permalink" href="cha-tuning-io.html#cha-tuning-io-schedulers-blkmq">#</a></h2><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-sle/edit/maintenance/SLE12SP5/xml/tuning_storagescheduler.xml" title="Edit source document"> </a></div></div></div></div></div><p>
   Below is a list of elevators available on <span class="productname"><span class="phrase">SUSE Linux Enterprise Server</span></span> for devices that use
   the blk-mq I/O path If an elevator has tunable parameters, they can be set
   with the command:
  </p><div class="verbatim-wrap"><pre class="screen">echo <em class="replaceable">VALUE</em> &gt; /sys/block/<em class="replaceable">DEVICE</em>/queue/iosched/<em class="replaceable">TUNABLE</em></pre></div><p>
   In command above, <em class="replaceable">VALUE</em> is the desired value for
   the <em class="replaceable">TUNABLE</em> and <em class="replaceable">DEVICE</em>
   is the block device.
  </p><p>
   To find out what elevators are available for a device
   (<code class="systemitem">sda</code> for example), run the following command (the
   currently selected scheduler is listed in brackets):
  </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code>cat /sys/block/sda/queue/scheduler
[mq-deadline] kyber bfq none</pre></div><div id="id-1.8.7.2.7.7" data-id-title="Scheduler options when switching from legacy block to blk-mq I/O path" class="admonition note normal"><img class="symbol" alt="Note" title="Note" src="static/images/icon-note.svg"/><div class="admon-title">Note: Scheduler options when switching from
    legacy block to blk-mq I/O path</div><p>
      When switching from legacy block to blk-mq I/O path for a device,
      the <code class="option">none</code> option is roughly comparable to
      <code class="option">noop</code>, <code class="option">mq-deadline</code> is comparable
      to <code class="option">deadline</code>, and <code class="option">bfq</code> is
      comparable to <code class="option">cfq</code>.
     </p></div><section class="sect2" id="sec-tuning-io-schedulers-mqdeadline" data-id-title="MQ-DEADLINE"><div class="titlepage"><div><div><div class="title-container"><h3 class="title"><span class="title-number-name"><span class="title-number">12.3.1 </span><span class="title-name"><code class="systemitem">MQ-DEADLINE</code></span></span> <a title="Permalink" class="permalink" href="cha-tuning-io.html#sec-tuning-io-schedulers-mqdeadline">#</a></h3><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-sle/edit/maintenance/SLE12SP5/xml/tuning_storagescheduler.xml" title="Edit source document"> </a></div></div></div></div></div><p>
    <code class="systemitem">MQ-DEADLINE</code> is a latency-oriented
    I/O scheduler. It is a modification of
    <code class="systemitem">DEADLINE</code> scheduler for blk-mq I/O
    path (refer to <a class="xref" href="cha-tuning-io.html#sec-tuning-io-schedulers-deadline" title="12.2.3. DEADLINE">Section 12.2.3, “<code class="systemitem">DEADLINE</code>”</a>).
    <code class="systemitem">MQ-DEADLINE</code> has the same set
    of tunable parameters. Please refer to
    <a class="xref" href="cha-tuning-io.html#tab-tunables-deadline" title="DEADLINE tunable parameters">Table 12.2, “<code class="systemitem">DEADLINE</code> tunable parameters”</a> for a description.
   </p></section><section class="sect2" id="sec-tuning-io-schedulers-none" data-id-title="NONE"><div class="titlepage"><div><div><div class="title-container"><h3 class="title"><span class="title-number-name"><span class="title-number">12.3.2 </span><span class="title-name"><code class="systemitem">NONE</code></span></span> <a title="Permalink" class="permalink" href="cha-tuning-io.html#sec-tuning-io-schedulers-none">#</a></h3><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-sle/edit/maintenance/SLE12SP5/xml/tuning_storagescheduler.xml" title="Edit source document"> </a></div></div></div></div></div><p>
    When <code class="systemitem">NONE</code> is selected as I/O
    elevator option for blk-mq, no I/O scheduler is used, and I/O requests are
    passed down to the device without further I/O scheduling interaction. In
    this respect, it is comparable to
    <code class="systemitem">NOOP</code> scheduler for the legacy
    block I/O path (see <a class="xref" href="cha-tuning-io.html#sec-tuning-io-schedulers-noop" title="12.2.2. NOOP">Section 12.2.2, “<code class="systemitem">NOOP</code>”</a>).
   </p><p>
    <code class="systemitem">NONE</code> is the default for NVM
    Express devices. With no overhead compared to other I/O elevator options,
    it is considered the fastest way of passing down I/O requests on multiple
    queues to such devices.
   </p><p>
    There are no tunable parameters for
    <code class="systemitem">NONE</code>.
   </p></section><section class="sect2" id="sec-tuning-io-schedulers-bfq" data-id-title="BFQ (Budget Fair Queueing)"><div class="titlepage"><div><div><div class="title-container"><h3 class="title"><span class="title-number-name"><span class="title-number">12.3.3 </span><span class="title-name"><code class="systemitem">BFQ</code> (Budget Fair Queueing)</span></span> <a title="Permalink" class="permalink" href="cha-tuning-io.html#sec-tuning-io-schedulers-bfq">#</a></h3><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-sle/edit/maintenance/SLE12SP5/xml/tuning_storagescheduler.xml" title="Edit source document"> </a></div></div></div></div></div><p>
    <code class="systemitem">BFQ</code> is a fairness-oriented
    scheduler. It is described as "a proportional-share storage-I/O scheduling
    algorithm based on the slice-by-slice service scheme of CFQ. But BFQ
    assigns budgets, measured in number of sectors, to processes instead of
    time slices." (Source:

    <a class="link" href="https://github.com/torvalds/linux/blob/6f7da290413ba713f0cdd9ff1a2a9bb129ef4f6c/block/bfq-iosched.c#L31" target="_blank">linux-4.12/block/bfq-iosched.c</a>)
   </p><p>
    <code class="systemitem">BFQ</code> allows to assign I/O
    priorities to tasks which are taken into account during scheduling
    decisions (see <a class="xref" href="cha-tuning-resources.html#cha-tuning-resources-disk-ionice" title="8.3.3. Prioritizing Disk Access with ionice">Section 8.3.3, “Prioritizing Disk Access with <code class="command">ionice</code>”</a>).
   </p><p>
    <code class="systemitem">BFQ</code> scheduler has following
    tunable parameters:
   </p><div class="table" id="tab-tunables-bfq" data-id-title="BFQ tunable parameters"><div class="title-container"><div class="table-title-wrap"><div class="table-title"><span class="title-number-name"><span class="title-number">Table 12.3: </span><span class="title-name"><code class="systemitem">BFQ</code> tunable parameters </span></span><a title="Permalink" class="permalink" href="cha-tuning-io.html#tab-tunables-bfq">#</a></div></div><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-sle/edit/maintenance/SLE12SP5/xml/tuning_storagescheduler.xml" title="Edit source document"> </a></div></div><div class="table-contents"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col class="1"/><col class="2"/></colgroup><thead><tr><th style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         File
        </p>
       </th><th style="border-bottom: 1px solid ; ">
        <p>
         Description
        </p>
       </th></tr></thead><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">slice_idle</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Value in milliseconds specifies how long to idle, waiting for next
         request on an empty queue.
        </p>
        <p>
         Default is <code class="literal">8</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">slice_idle_us</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Same as <code class="filename">slice_idle</code> but in microseconds.
        </p>
        <p>
         Default is <code class="literal">8000</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">low_latency</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Enables (1) or disables (0)
         <code class="systemitem">BFQ</code>'s low latency mode.
         This mode prioritizes certain applications (for example, if
         interactive) such that they observe lower latency.
        </p>
        <p>
         Default is <code class="literal">1</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">back_seek_max</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Maximum value (in Kbytes) for backward seeking.
        </p>
        <p>
         Default is <code class="literal">16384</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">back_seek_penalty</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Used to compute the cost of backward seeking.
        </p>
        <p>
         Default is <code class="literal">2</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">fifo_expire_async</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Value (in milliseconds) is used to set the timeout of asynchronous
         requests.
        </p>
        <p>
         Default is <code class="literal">250</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">fifo_expire_sync</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Value in milliseconds specifies the timeout of synchronous requests.
        </p>
        <p>
         Default is <code class="literal">125</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">timeout_sync</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Maximum time in milliseconds that a task (queue) is serviced after it
         has been selected.
        </p>
        <p>
         Default is <code class="literal">124</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">max_budget</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Limit for number of sectors that are served at maximum within
         <code class="literal">timeout_sync</code>. If set to <code class="literal">0</code>
         <code class="systemitem">BFQ</code> internally
         calculates a value based on <code class="filename">timeout_sync</code> and an
         estimated peak rate.
        </p>
        <p>
         Default is <code class="literal">0</code> (set to auto-tuning).
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; ">
        <p>
         <code class="filename">strict_guarantees</code>
        </p>
       </td><td>
        <p>
         Enables (1) or disables (0)
         <code class="systemitem">BFQ</code> specific queue
         handling required to give stricter bandwidth sharing guarantees under
         certain conditions.
        </p>
        <p>
         Default is <code class="literal">0</code>.
        </p>
       </td></tr></tbody></table></div></div></section><section class="sect2" id="sec-tuning-io-schedulers-kyber" data-id-title="KYBER"><div class="titlepage"><div><div><div class="title-container"><h3 class="title"><span class="title-number-name"><span class="title-number">12.3.4 </span><span class="title-name"><code class="systemitem">KYBER</code></span></span> <a title="Permalink" class="permalink" href="cha-tuning-io.html#sec-tuning-io-schedulers-kyber">#</a></h3><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-sle/edit/maintenance/SLE12SP5/xml/tuning_storagescheduler.xml" title="Edit source document"> </a></div></div></div></div></div><p>
    <code class="systemitem">KYBER</code> is a latency-oriented I/O
    scheduler. It makes it possible to set target latencies for reads and
    synchronous writes and throttles I/O requests in order to try to meet these
    target latencies.
   </p><div class="table" id="tab-tunables-kyber" data-id-title="KYBER tunable parameters"><div class="title-container"><div class="table-title-wrap"><div class="table-title"><span class="title-number-name"><span class="title-number">Table 12.4: </span><span class="title-name"><code class="systemitem">KYBER</code> tunable parameters </span></span><a title="Permalink" class="permalink" href="cha-tuning-io.html#tab-tunables-kyber">#</a></div></div><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-sle/edit/maintenance/SLE12SP5/xml/tuning_storagescheduler.xml" title="Edit source document"> </a></div></div><div class="table-contents"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col class="1"/><col class="2"/></colgroup><thead><tr><th style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         File
        </p>
       </th><th style="border-bottom: 1px solid ; ">
        <p>
         Description
        </p>
       </th></tr></thead><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; ">
        <p>
         <code class="filename">read_lat_nsec</code>
        </p>
       </td><td style="border-bottom: 1px solid ; ">
        <p>
         Sets the target latency for read operations in nanoseconds.
        </p>
        <p>
         Default is <code class="literal">2000000</code>.
        </p>
       </td></tr><tr><td style="border-right: 1px solid ; ">
        <p>
         <code class="filename">write_lat_nsec</code>
        </p>
       </td><td>
        <p>
         Sets the target latency for write operations in nanoseconds.
        </p>
        <p>
         Default is <code class="literal">10000000</code>.
        </p>
       </td></tr></tbody></table></div></div></section></section><section class="sect1" id="cha-tuning-io-barrier" data-id-title="I/O Barrier Tuning"><div class="titlepage"><div><div><div class="title-container"><h2 class="title"><span class="title-number-name"><span class="title-number">12.4 </span><span class="title-name">I/O Barrier Tuning</span></span> <a title="Permalink" class="permalink" href="cha-tuning-io.html#cha-tuning-io-barrier">#</a></h2><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-sle/edit/maintenance/SLE12SP5/xml/tuning_storagescheduler.xml" title="Edit source document"> </a></div></div></div></div></div><p>
   
   Most file systems (such as XFS, Ext3, Ext4, or ReiserFS) send write barriers
   to disk after fsync or during transaction commits. Write barriers enforce
   proper ordering of writes, making volatile disk write caches safe to use (at
   some performance penalty). If your disks are battery-backed in one way or
   another, disabling barriers can safely improve performance.
  </p><p>
   Sending write barriers can be disabled using the <code class="option">nobarrier</code>
   mount option.
  </p><div id="id-1.8.7.2.8.4" data-id-title="Disabling Barriers Can Lead to Data Loss" class="admonition warning normal"><img class="symbol" alt="Warning" title="Warning" src="static/images/icon-warning.svg"/><div class="admon-title">Warning: Disabling Barriers Can Lead to Data Loss</div><p>
    Disabling barriers when disks cannot guarantee caches are properly written
    in case of power failure can lead to severe file system corruption and data
    loss.
   </p></div></section><section class="sect1" id="cha-tuning-io-scsimq" data-id-title="Enable blk-mq I/O Path for SCSI by Default"><div class="titlepage"><div><div><div class="title-container"><h2 class="title"><span class="title-number-name"><span class="title-number">12.5 </span><span class="title-name">Enable blk-mq I/O Path for SCSI by Default</span></span> <a title="Permalink" class="permalink" href="cha-tuning-io.html#cha-tuning-io-scsimq">#</a></h2><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-sle/edit/maintenance/SLE12SP5/xml/tuning_storagescheduler.xml" title="Edit source document"> </a></div></div></div></div></div><p>
   Block multiqueue (blk-mq) is a multi-queue block I/O queueing mechanism.
   Blk-mq uses per-cpu software queues to queue I/O requests. The software
   queues are mapped to one or more hardware submission queues. Blk-mq
   significantly reduces lock contention. In particular blk-mq improves
   performance for devices that support a high number of input/output
   operations per second (IOPS). Blk-mq is already the default for some
   devices, for example, NVM Express devices.
  </p><p>
   Blk-mq has a different set of I/O scheduler options. There is
   <code class="systemitem">MQ-DEADLINE</code> (comparable to
   <code class="systemitem">DEADLINE</code>) and
   <code class="systemitem">NONE</code> (comparable to
   <code class="systemitem">NOOP</code>). There is no longer
   <code class="systemitem">CFQ</code> I/O scheduler with blk-mq. But
   there are two new I/O schedulers:
   <code class="systemitem">BFQ</code> and
   <code class="systemitem">KYBER</code>. These changes in I/O
   scheduling can cause performance differences with blk-mq compared to legacy
   block I/O path. Therefore, blk-mq is not enabled by default for SCSI
   devices.
  </p><p>
   If you have fast SCSI devices (for example, SSDs) instead of SCSI hard disks
   attached to your system, consider switching to blk-mq for SCSI. This is done
   using the kernel command line option
   <code class="literal">scsi_mod.use_blk_mq=1</code>. If you have also attached SCSI
   hard disks (spinning devices) to your system, make sure to switch to
   <code class="systemitem">BFQ</code> I/O scheduler for the
   spinning devices to avoid their significant performance degradation.
  </p></section></section><nav class="bottom-pagination"><div><a class="pagination-link prev" href="part-tuning-kernel.html"><span class="pagination-relation">Previous</span><span class="pagination-label"><span class="title-number">Part V </span>Kernel Tuning</span></a> </div><div><a class="pagination-link next" href="cha-tuning-taskscheduler.html"><span class="pagination-relation">Next</span><span class="pagination-label"><span class="title-number">Chapter 13 </span>Tuning the Task Scheduler</span></a> </div></nav></article><aside id="_side-toc-page" class="side-toc"><div class="side-title">On this page</div><div class="toc"><ul><li><span class="sect1"><a href="cha-tuning-io.html#cha-tuning-io-switch"><span class="title-number">12.1 </span><span class="title-name">Switching I/O Scheduling</span></a></span></li><li><span class="sect1"><a href="cha-tuning-io.html#cha-tuning-io-schedulers"><span class="title-number">12.2 </span><span class="title-name">Available I/O Elevators</span></a></span></li><li><span class="sect1"><a href="cha-tuning-io.html#cha-tuning-io-schedulers-blkmq"><span class="title-number">12.3 </span><span class="title-name">Available I/O Elevators with blk-mq I/O path</span></a></span></li><li><span class="sect1"><a href="cha-tuning-io.html#cha-tuning-io-barrier"><span class="title-number">12.4 </span><span class="title-name">I/O Barrier Tuning</span></a></span></li><li><span class="sect1"><a href="cha-tuning-io.html#cha-tuning-io-scsimq"><span class="title-number">12.5 </span><span class="title-name">Enable blk-mq I/O Path for SCSI by Default</span></a></span></li></ul></div><div class="side-title">Share this page</div><ul class="share"><li><a id="_share-fb" href="#" title="Facebook"> </a></li><li><a id="_share-in" href="#" title="LinkedIn"> </a></li><li><a id="_share-tw" href="#" title="Twitter/X"> </a></li><li><a id="_share-mail" href="#" title="E-Mail"> </a></li><li><a id="_print-button" href="#" title="Print this page"> </a></li></ul> </aside></main><footer id="_footer"><div class="growth-inhibitor"><div class="copy"><span class="copy__rights">© SUSE
                 2024</span></div></div></footer></body></html>